{"version":3,"file":"react-ssr-prepass.production.min.js","sources":["../src/symbols.js","../src/internals/context.js","../src/internals/dispatcher.js","../src/visitor.js"],"sourcesContent":["// @flow\n\nimport type { Node } from 'react'\nimport * as is from 'react-is'\n\n/** Literal types representing the ReactSymbol values. These values do not actually match the values from react-is! */\nexport type ReactSymbol =\n  | 'react.element' /* 0xeac7 | Symbol(react.element) */\n  | 'react.portal' /* 0xeaca | Symbol(react.portal) */\n  | 'react.fragment' /* 0xeacb | Symbol(react.fragment) */\n  | 'react.strict_mode' /* 0xeacc | Symbol(react.strict_mode) */\n  | 'react.profiler' /* 0xead2 | Symbol(react.profiler) */\n  | 'react.provider' /* 0xeacd | Symbol(react.provider) */\n  | 'react.context' /* 0xeace | Symbol(react.context) */\n  | 'react.concurrent_mode' /* 0xeacf | Symbol(react.concurrent_mode) */\n  | 'react.forward_ref' /* 0xead0 | Symbol(react.forward_ref) */\n  | 'react.suspense' /* 0xead1 | Symbol(react.suspense) */\n  | 'react.memo' /* 0xead3 | Symbol(react.memo) */\n  | 'react.lazy' /* 0xead4 | Symbol(react.lazy) */\n\nexport const REACT_ELEMENT_TYPE: 'react.element' = is.Element\nexport const REACT_PORTAL_TYPE: 'react.portal' = is.Portal\nexport const REACT_FRAGMENT_TYPE: 'react.fragment' = is.Fragment\nexport const REACT_STRICT_MODE_TYPE: 'react.strict_mode' = is.StrictMode\nexport const REACT_PROFILER_TYPE: 'react.profiler' = is.Profiler\nexport const REACT_PROVIDER_TYPE: 'react.provider' = is.ContextProvider\nexport const REACT_CONTEXT_TYPE: 'react.context' = is.ContextConsumer\nexport const REACT_CONCURRENT_MODE_TYPE: 'react.concurrent_mode' =\n  is.ConcurrentMode\nexport const REACT_FORWARD_REF_TYPE: 'react.forward_ref' = is.ForwardRef\nexport const REACT_SUSPENSE_TYPE: 'react.suspense' = is.Suspense\nexport const REACT_MEMO_TYPE: 'react.memo' = is.Memo\nexport const REACT_LAZY_TYPE: 'react.lazy' = is.Lazy\n","// @flow\n\nimport type {\n  AbstractContext,\n  UserElement,\n  ContextMap,\n  ContextStore\n} from '../types'\n\n/* The context is kept as a Map from a Context value to the current\n   value on the React element tree.\n   The legacy context is kept as a simple object.\n   When the tree is being walked modifications are made by assigning\n   new legacy context maps or new context values.\n   These changes are kept in the `prev` variables and must be flushed\n   before continuing to walk the tree.\n   After walking the children they can be restored.\n   This way the context recursively restores itself on the way up. */\n\ntype ContextEntry = [AbstractContext, mixed]\n\nlet currentContextStore: ContextStore = new Map()\nlet currentContextMap: ContextMap = {}\n\nlet prevContextMap: void | ContextMap = undefined\nlet prevContextEntry: void | ContextEntry = undefined\n\nexport const getCurrentContextMap = (): ContextMap =>\n  Object.assign({}, currentContextMap)\nexport const getCurrentContextStore = (): ContextStore =>\n  new Map(currentContextStore)\n\nexport const flushPrevContextMap = (): void | ContextMap => {\n  const prev = prevContextMap\n  prevContextMap = undefined\n  return prev\n}\n\nexport const flushPrevContextStore = (): void | ContextEntry => {\n  const prev = prevContextEntry\n  prevContextEntry = undefined\n  return prev\n}\n\nexport const restoreContextMap = (prev: ContextMap) => {\n  Object.assign(currentContextMap, prev)\n}\n\nexport const restoreContextStore = (prev: ContextEntry) => {\n  currentContextStore.set(prev[0], prev[1])\n}\n\nexport const setCurrentContextMap = (map: ContextMap) => {\n  prevContextMap = undefined\n  currentContextMap = map\n}\n\nexport const setCurrentContextStore = (store: ContextStore) => {\n  prevContextEntry = undefined\n  currentContextStore = store\n}\n\nexport const assignContextMap = (map: ContextMap) => {\n  prevContextMap = {}\n  for (const name in map) {\n    prevContextMap[name] = currentContextMap[name]\n    currentContextMap[name] = map[name]\n  }\n}\n\nexport const setContextValue = (context: AbstractContext, value: mixed) => {\n  prevContextEntry = [context, currentContextStore.get(context)]\n  currentContextStore.set(context, value)\n}\n\nexport const readContextValue = (context: AbstractContext) => {\n  const value = currentContextStore.get(context)\n  if (value !== undefined) {\n    return value\n  }\n\n  // Return default if context has no value yet\n  return context._currentValue\n}\n\nconst emptyContext = {}\n\nexport const maskContext = (type: $PropertyType<UserElement, 'type'>) => {\n  const { contextType, contextTypes } = type\n\n  if (contextType) {\n    return readContextValue(contextType)\n  } else if (!contextTypes) {\n    return emptyContext\n  }\n\n  const maskedContext = {}\n  for (const name in contextTypes) {\n    maskedContext[name] = currentContextMap[name]\n  }\n\n  return maskedContext\n}\n","// @flow\n// Source: https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js\n\nimport is from 'object-is'\nimport { readContextValue } from './context'\n\nimport type {\n  AbstractContext,\n  BasicStateAction,\n  Dispatch,\n  Update,\n  UpdateQueue,\n  Hook\n} from '../types'\n\nexport opaque type Identity = {}\n\nlet currentIdentity: Identity | null = null\n\nexport const makeIdentity = (): Identity => ({})\n\nexport const setCurrentIdentity = (id: Identity | null) => {\n  currentIdentity = id\n}\n\nexport const getCurrentIdentity = (): Identity => {\n  if (currentIdentity === null) {\n    throw new Error(\n      '[react-ssr-prepass] Hooks can only be called inside the body of a function component. ' +\n        '(https://fb.me/react-invalid-hook-call)'\n    )\n  }\n\n  // NOTE: The warning that is used in ReactPartialRendererHooks is obsolete\n  // in a prepass, since it'll be caught by a subsequent renderer anyway\n  // https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L63-L71\n\n  return (currentIdentity: Identity)\n}\n\nlet firstWorkInProgressHook: Hook | null = null\nlet workInProgressHook: Hook | null = null\n// Whether the work-in-progress hook is a re-rendered hook\nlet isReRender: boolean = false\n// Whether an update was scheduled during the currently executing render pass.\nlet didScheduleRenderPhaseUpdate: boolean = false\n// Lazily created map of render-phase updates\nlet renderPhaseUpdates: Map<UpdateQueue<any>, Update<any>> | null = null\n// Counter to prevent infinite loops.\nlet numberOfReRenders: number = 0\nconst RE_RENDER_LIMIT = 25\n\nexport const getFirstHook = (): Hook | null => firstWorkInProgressHook\n\nexport const setFirstHook = (hook: Hook | null) => {\n  firstWorkInProgressHook = hook\n}\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null\n) {\n  // NOTE: The warnings that are used in ReactPartialRendererHooks are obsolete\n  // in a prepass, since these issues will be caught by a subsequent renderer anyway\n  if (prevDeps === null) {\n    return false\n  }\n\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (!is(nextDeps[i], prevDeps[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction createHook(): Hook {\n  return {\n    memoizedState: null,\n    queue: null,\n    next: null\n  }\n}\n\nfunction createWorkInProgressHook(): Hook {\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    if (firstWorkInProgressHook === null) {\n      isReRender = false\n      firstWorkInProgressHook = workInProgressHook = createHook()\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      isReRender = true\n      workInProgressHook = firstWorkInProgressHook\n    }\n  } else {\n    if (workInProgressHook.next === null) {\n      isReRender = false\n      // Append to the end of the list\n      workInProgressHook = workInProgressHook.next = createHook()\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      isReRender = true\n      workInProgressHook = workInProgressHook.next\n    }\n  }\n  return workInProgressHook\n}\n\nexport function renderWithHooks(\n  Component: any,\n  props: any,\n  refOrContext: any\n): any {\n  let children = Component(props, refOrContext)\n\n  // NOTE: Excessive rerenders won't throw but will instead abort rendering\n  // since a subsequent renderer can throw when this issue occurs instead\n  while (numberOfReRenders < RE_RENDER_LIMIT && didScheduleRenderPhaseUpdate) {\n    // Updates were scheduled during the render phase. They are stored in\n    // the `renderPhaseUpdates` map. Call the component again, reusing the\n    // work-in-progress hooks and applying the additional updates on top. Keep\n    // restarting until no more updates are scheduled.\n    didScheduleRenderPhaseUpdate = false\n    numberOfReRenders += 1\n    // Start over from the beginning of the list\n    workInProgressHook = null\n    children = Component(props, refOrContext)\n  }\n\n  // This will be reset by renderer\n  // firstWorkInProgressHook = null\n\n  numberOfReRenders = 0\n  renderPhaseUpdates = null\n  workInProgressHook = null\n\n  return children\n}\n\nfunction readContext(context: AbstractContext, _: void | number | boolean) {\n  // NOTE: The warning that is used in ReactPartialRendererHooks is obsolete\n  // in a prepass, since it'll be caught by a subsequent renderer anyway\n  // https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L215-L223\n  return readContextValue(context)\n}\n\nfunction useContext(context: AbstractContext, _: void | number | boolean) {\n  getCurrentIdentity()\n  return readContextValue(context)\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  // $FlowFixMe\n  return typeof action === 'function' ? action(state) : action\n}\n\nfunction useState<S>(\n  initialState: (() => S) | S\n): [S, Dispatch<BasicStateAction<S>>] {\n  return useReducer(\n    basicStateReducer,\n    // useReducer has a special case to support lazy useState initializers\n    (initialState: any)\n  )\n}\n\nfunction useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S\n): [S, Dispatch<A>] {\n  const id = getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n\n  if (isReRender) {\n    // This is a re-render. Apply the new render phase updates to the previous\n    // current hook.\n    const queue: UpdateQueue<A> = (workInProgressHook.queue: any)\n    const dispatch: Dispatch<A> = (queue.dispatch: any)\n    if (renderPhaseUpdates !== null) {\n      // Render phase updates are stored in a map of queue -> linked list\n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)\n      if (firstRenderPhaseUpdate !== undefined) {\n        renderPhaseUpdates.delete(queue)\n        let newState = workInProgressHook.memoizedState\n        let update = firstRenderPhaseUpdate\n        do {\n          // Process this render phase update. We don't have to check the\n          // priority because it will always be the same as the current\n          // render's.\n          const action = update.action\n          newState = reducer(newState, action)\n          update = update.next\n        } while (update !== null)\n\n        workInProgressHook.memoizedState = newState\n\n        return [newState, dispatch]\n      }\n    }\n    return [workInProgressHook.memoizedState, dispatch]\n  } else {\n    let initialState\n    if (reducer === basicStateReducer) {\n      // Special case for `useState`.\n      initialState =\n        typeof initialArg === 'function'\n          ? ((initialArg: any): () => S)()\n          : ((initialArg: any): S)\n    } else {\n      initialState =\n        init !== undefined ? init(initialArg) : ((initialArg: any): S)\n    }\n    workInProgressHook.memoizedState = initialState\n    const queue: UpdateQueue<A> = (workInProgressHook.queue = {\n      last: null,\n      dispatch: null\n    })\n    const dispatch: Dispatch<A> = (queue.dispatch = (dispatchAction.bind(\n      null,\n      id,\n      queue\n    ): any))\n    return [workInProgressHook.memoizedState, dispatch]\n  }\n}\n\nfunction useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T {\n  getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n\n  const nextDeps = deps === undefined ? null : deps\n\n  if (workInProgressHook !== null) {\n    const prevState = workInProgressHook.memoizedState\n    if (prevState !== null) {\n      if (nextDeps !== null) {\n        const prevDeps = prevState[1]\n        if (areHookInputsEqual(nextDeps, prevDeps)) {\n          return prevState[0]\n        }\n      }\n    }\n  }\n\n  const nextValue = nextCreate()\n  workInProgressHook.memoizedState = [nextValue, nextDeps]\n  return nextValue\n}\n\nfunction useRef<T>(initialValue: T): { current: T } {\n  getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n  const previousRef = workInProgressHook.memoizedState\n  if (previousRef === null) {\n    const ref = { current: initialValue }\n    workInProgressHook.memoizedState = ref\n    return ref\n  } else {\n    return previousRef\n  }\n}\n\nfunction dispatchAction<A>(\n  componentIdentity: Identity,\n  queue: UpdateQueue<A>,\n  action: A\n) {\n  if (componentIdentity === getCurrentIdentity()) {\n    // This is a render phase update. Stash it in a lazily-created map of\n    // queue -> linked list of updates. After this render pass, we'll restart\n    // and apply the stashed updates on top of the work-in-progress hook.\n    didScheduleRenderPhaseUpdate = true\n    const update: Update<A> = {\n      action,\n      next: null\n    }\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map()\n    }\n    const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update)\n    } else {\n      // Append the update to the end of the list.\n      let lastRenderPhaseUpdate = firstRenderPhaseUpdate\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next\n      }\n      lastRenderPhaseUpdate.next = update\n    }\n  } else {\n    // This means an update has happened after the function component has\n    // returned. On the server this is a no-op. In React Fiber, the update\n    // would be scheduled for a future render.\n  }\n}\n\nfunction useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  // Callbacks are passed as they are in the server environment.\n  return callback\n}\n\nfunction noop(): void {}\n\nexport const Dispatcher = {\n  readContext,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  useCallback,\n  // ignore useLayout effect completely as usage of it will be caught\n  // in a subsequent render pass\n  useLayoutEffect: noop,\n  // useImperativeHandle is not run in the server environment\n  useImperativeHandle: noop,\n  // Effects are not run in the server environment.\n  useEffect: noop,\n  // Debugging effect\n  useDebugValue: noop\n}\n","// @flow\n\nimport type { Node, ComponentType } from 'react'\nimport { typeOf, shouldConstruct, getChildrenArray } from './element'\n\nimport {\n  mountFunctionComponent,\n  mountClassComponent,\n  mountLazyComponent\n} from './render'\n\nimport type {\n  Visitor,\n  Frame,\n  ContextMap,\n  DefaultProps,\n  ComponentStatics,\n  LazyElement,\n  AbstractElement,\n  ConsumerElement,\n  ProviderElement,\n  FragmentElement,\n  SuspenseElement,\n  ForwardRefElement,\n  MemoElement,\n  UserElement,\n  DOMElement\n} from './types'\n\nimport {\n  flushPrevContextMap,\n  flushPrevContextStore,\n  restoreContextMap,\n  restoreContextStore,\n  readContextValue,\n  setContextValue\n} from './internals'\n\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_PROVIDER_TYPE,\n  REACT_CONTEXT_TYPE,\n  REACT_CONCURRENT_MODE_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE\n} from './symbols'\n\nconst render = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[],\n  visitor: Visitor,\n  element?: UserElement\n) => {\n  return shouldConstruct(type)\n    ? mountClassComponent(type, props, queue, visitor, element)\n    : mountFunctionComponent(type, props, queue, visitor, element)\n}\n\nexport const visitElement = (\n  element: AbstractElement,\n  queue: Frame[],\n  visitor: Visitor\n): AbstractElement[] => {\n  switch (typeOf(element)) {\n    case REACT_SUSPENSE_TYPE:\n    case REACT_STRICT_MODE_TYPE:\n    case REACT_CONCURRENT_MODE_TYPE:\n    case REACT_PROFILER_TYPE:\n    case REACT_FRAGMENT_TYPE: {\n      // These element types are simply traversed over but otherwise ignored\n      const fragmentElement = ((element: any):\n        | FragmentElement\n        | SuspenseElement)\n      return getChildrenArray(fragmentElement.props.children)\n    }\n\n    case REACT_PROVIDER_TYPE: {\n      const providerElement = ((element: any): ProviderElement)\n      // Add provider's value prop to context\n      const { value, children } = providerElement.props\n      setContextValue(providerElement.type._context, value)\n\n      return getChildrenArray(children)\n    }\n\n    case REACT_CONTEXT_TYPE: {\n      const consumerElement = ((element: any): ConsumerElement)\n      const { children } = consumerElement.props\n\n      // Read from context and call children, if it's been passed\n      if (typeof children === 'function') {\n        const type = (consumerElement.type: any)\n        const context = typeof type._context === 'object' ? type._context : type\n        const value = readContextValue(context)\n        return getChildrenArray(children(value))\n      } else {\n        return []\n      }\n    }\n\n    case REACT_LAZY_TYPE: {\n      const lazyElement = ((element: any): LazyElement)\n      const type = lazyElement.type\n      const child = mountLazyComponent(type, lazyElement.props, queue)\n      return getChildrenArray(child)\n    }\n\n    case REACT_MEMO_TYPE: {\n      const memoElement = ((element: any): MemoElement)\n      const type = memoElement.type.type\n      const child = render(type, memoElement.props, queue, visitor)\n      return getChildrenArray(child)\n    }\n\n    case REACT_FORWARD_REF_TYPE: {\n      const refElement = ((element: any): ForwardRefElement)\n      // Treat inner type as the component instead of React.forwardRef itself\n      const type = refElement.type.render\n      const props = refElement.props\n      const child = mountFunctionComponent(type, props, queue, visitor)\n      return getChildrenArray(child)\n    }\n\n    case REACT_ELEMENT_TYPE: {\n      const el = ((element: any): UserElement | DOMElement)\n      if (typeof el.type === 'string') {\n        // String elements can be skipped, so we just return children\n        return getChildrenArray(el.props.children)\n      } else {\n        const userElement = ((element: any): UserElement)\n        const { type, props } = userElement\n        const child = render(type, props, queue, visitor, userElement)\n        return getChildrenArray(child)\n      }\n    }\n\n    case REACT_PORTAL_TYPE:\n    // Portals are unsupported during SSR since they're DOM-only\n    default:\n      return []\n  }\n}\n\nconst visitChild = (\n  child: AbstractElement,\n  queue: Frame[],\n  visitor: Visitor\n) => {\n  const children = visitElement(child, queue, visitor)\n  // Flush the context changes\n  const prevMap = flushPrevContextMap()\n  const prevStore = flushPrevContextStore()\n\n  visitChildren(children, queue, visitor)\n\n  // Restore context changes after children have been walked\n  if (prevMap !== undefined) {\n    restoreContextMap(prevMap)\n  }\n\n  if (prevStore !== undefined) {\n    restoreContextStore(prevStore)\n  }\n}\n\nexport const visitChildren = (\n  children: AbstractElement[],\n  queue: Frame[],\n  visitor: Visitor\n) => {\n  for (let i = 0, l = children.length; i < l; i++) {\n    visitChild(children[i], queue, visitor)\n  }\n}\n"],"names":["is","undefined","action","render"],"mappings":"yMAuBmCA,uFAMAA,kOCPdC,i0BCmI8CC,8wJC/B3BC"}