function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var is = require('react-is');
var React = require('react');
var React__default = _interopDefault(React);
var is$1 = _interopDefault(require('object-is'));

// 
/** Literal types representing the ReactSymbol values. These values do not actually match the values from react-is! */

/* 0xead4 | Symbol(react.lazy) */

var REACT_ELEMENT_TYPE = is.Element;
var REACT_PORTAL_TYPE = is.Portal;
var REACT_FRAGMENT_TYPE = is.Fragment;
var REACT_STRICT_MODE_TYPE = is.StrictMode;
var REACT_PROFILER_TYPE = is.Profiler;
var REACT_PROVIDER_TYPE = is.ContextProvider;
var REACT_CONTEXT_TYPE = is.ContextConsumer;
var REACT_CONCURRENT_MODE_TYPE = is.ConcurrentMode;
var REACT_FORWARD_REF_TYPE = is.ForwardRef;
var REACT_SUSPENSE_TYPE = is.Suspense;
var REACT_MEMO_TYPE = is.Memo;
var REACT_LAZY_TYPE = is.Lazy;

// 
/** Is a given Component a class component */

var shouldConstruct = function (Comp) { return Comp.prototype && Comp.prototype.isReactComponent; };
/** Determine the type of element using react-is with applied fixes */

var typeOf = function (x) {
  switch (x.$$typeof) {
    case REACT_PORTAL_TYPE:
      return REACT_PORTAL_TYPE;

    case REACT_ELEMENT_TYPE:
      switch (x.type) {
        case REACT_CONCURRENT_MODE_TYPE:
          return REACT_CONCURRENT_MODE_TYPE;

        case REACT_FRAGMENT_TYPE:
          return REACT_FRAGMENT_TYPE;

        case REACT_PROFILER_TYPE:
          return REACT_PROFILER_TYPE;

        case REACT_STRICT_MODE_TYPE:
          return REACT_STRICT_MODE_TYPE;

        case REACT_SUSPENSE_TYPE:
          return REACT_SUSPENSE_TYPE;

        default:
          {
            switch (x.type && x.type.$$typeof) {
              case REACT_LAZY_TYPE:
                return REACT_LAZY_TYPE;

              case REACT_MEMO_TYPE:
                return REACT_MEMO_TYPE;

              case REACT_CONTEXT_TYPE:
                return REACT_CONTEXT_TYPE;

              case REACT_PROVIDER_TYPE:
                return REACT_PROVIDER_TYPE;

              case REACT_FORWARD_REF_TYPE:
                return REACT_FORWARD_REF_TYPE;

              default:
                return REACT_ELEMENT_TYPE;
            }
          }
      }

    default:
      return undefined;
  }
};
/** Rebound Children.toArray with modified AbstractElement types */

var toArray = React.Children.toArray;
/** Checks whether the `node` is an AbstractElement */

var isAbstractElement = function (node) { return node !== null && typeof node === 'object'; };
/** Returns a flat AbstractElement array for a given AbstractElement node */


var getChildrenArray = function (node) {
  // $FlowFixMe
  return toArray(node).filter(isAbstractElement);
};
/** Returns merged props given a props and defaultProps object */

var computeProps = function (props, defaultProps) {
  return typeof defaultProps === 'object' ? Object.assign({}, defaultProps, props) : props;
};

// 

/* The context is kept as a Map from a Context value to the current
   value on the React element tree.
   The legacy context is kept as a simple object.
   When the tree is being walked modifications are made by assigning
   new legacy context maps or new context values.
   These changes are kept in the `prev` variables and must be flushed
   before continuing to walk the tree.
   After walking the children they can be restored.
   This way the context recursively restores itself on the way up. */
var currentContextStore = new Map();
var currentContextMap = {};
var prevContextMap = undefined;
var prevContextEntry = undefined;
var getCurrentContextMap = function () { return Object.assign({}, currentContextMap); };
var getCurrentContextStore = function () { return new Map(currentContextStore); };
var flushPrevContextMap = function () {
  var prev = prevContextMap;
  prevContextMap = undefined;
  return prev;
};
var flushPrevContextStore = function () {
  var prev = prevContextEntry;
  prevContextEntry = undefined;
  return prev;
};
var restoreContextMap = function (prev) {
  Object.assign(currentContextMap, prev);
};
var restoreContextStore = function (prev) {
  currentContextStore.set(prev[0], prev[1]);
};
var setCurrentContextMap = function (map) {
  prevContextMap = undefined;
  currentContextMap = map;
};
var setCurrentContextStore = function (store) {
  prevContextEntry = undefined;
  currentContextStore = store;
};
var assignContextMap = function (map) {
  prevContextMap = {};

  for (var name in map) {
    prevContextMap[name] = currentContextMap[name];
    currentContextMap[name] = map[name];
  }
};
var setContextValue = function (context, value) {
  prevContextEntry = [context, currentContextStore.get(context)];
  currentContextStore.set(context, value);
};
var readContextValue = function (context) {
  var value = currentContextStore.get(context);

  if (value !== undefined) {
    return value;
  } // Return default if context has no value yet


  return context._currentValue;
};
var emptyContext = {};
var maskContext = function (type) {
  var contextType = type.contextType;
  var contextTypes = type.contextTypes;

  if (contextType) {
    return readContextValue(contextType);
  } else if (!contextTypes) {
    return emptyContext;
  }

  var maskedContext = {};

  for (var name in contextTypes) {
    maskedContext[name] = currentContextMap[name];
  }

  return maskedContext;
};

// 
var currentIdentity = null;
var makeIdentity = function () { return ({}); };
var setCurrentIdentity = function (id) {
  currentIdentity = id;
};
var getCurrentIdentity = function () {
  if (currentIdentity === null) {
    throw new Error('[react-ssr-prepass] Hooks can only be called inside the body of a function component. ' + '(https://fb.me/react-invalid-hook-call)');
  } // NOTE: The warning that is used in ReactPartialRendererHooks is obsolete
  // in a prepass, since it'll be caught by a subsequent renderer anyway
  // https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L63-L71


  return currentIdentity;
};
var firstWorkInProgressHook = null;
var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook

var isReRender = false; // Whether an update was scheduled during the currently executing render pass.

var didScheduleRenderPhaseUpdate = false; // Lazily created map of render-phase updates

var renderPhaseUpdates = null; // Counter to prevent infinite loops.

var numberOfReRenders = 0;
var RE_RENDER_LIMIT = 25;
var getFirstHook = function () { return firstWorkInProgressHook; };
var setFirstHook = function (hook) {
  firstWorkInProgressHook = hook;
};

function areHookInputsEqual(nextDeps, prevDeps) {
  // NOTE: The warnings that are used in ReactPartialRendererHooks are obsolete
  // in a prepass, since these issues will be caught by a subsequent renderer anyway
  if (prevDeps === null) {
    return false;
  }

  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (!is$1(nextDeps[i], prevDeps[i])) {
      return false;
    }
  }

  return true;
}

function createHook() {
  return {
    memoizedState: null,
    queue: null,
    next: null
  };
}

function createWorkInProgressHook() {
  if (workInProgressHook === null) {
    // This is the first hook in the list
    if (firstWorkInProgressHook === null) {
      isReRender = false;
      firstWorkInProgressHook = workInProgressHook = createHook();
    } else {
      // There's already a work-in-progress. Reuse it.
      isReRender = true;
      workInProgressHook = firstWorkInProgressHook;
    }
  } else {
    if (workInProgressHook.next === null) {
      isReRender = false; // Append to the end of the list

      workInProgressHook = workInProgressHook.next = createHook();
    } else {
      // There's already a work-in-progress. Reuse it.
      isReRender = true;
      workInProgressHook = workInProgressHook.next;
    }
  }

  return workInProgressHook;
}

function renderWithHooks(Component, props, refOrContext) {
  var children = Component(props, refOrContext); // NOTE: Excessive rerenders won't throw but will instead abort rendering
  // since a subsequent renderer can throw when this issue occurs instead

  while (numberOfReRenders < RE_RENDER_LIMIT && didScheduleRenderPhaseUpdate) {
    // Updates were scheduled during the render phase. They are stored in
    // the `renderPhaseUpdates` map. Call the component again, reusing the
    // work-in-progress hooks and applying the additional updates on top. Keep
    // restarting until no more updates are scheduled.
    didScheduleRenderPhaseUpdate = false;
    numberOfReRenders += 1; // Start over from the beginning of the list

    workInProgressHook = null;
    children = Component(props, refOrContext);
  } // This will be reset by renderer
  // firstWorkInProgressHook = null


  numberOfReRenders = 0;
  renderPhaseUpdates = null;
  workInProgressHook = null;
  return children;
}

function readContext(context, _) {
  // NOTE: The warning that is used in ReactPartialRendererHooks is obsolete
  // in a prepass, since it'll be caught by a subsequent renderer anyway
  // https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L215-L223
  return readContextValue(context);
}

function useContext(context, _) {
  getCurrentIdentity();
  return readContextValue(context);
}

function basicStateReducer(state, action) {
  // $FlowFixMe
  return typeof action === 'function' ? action(state) : action;
}

function useState(initialState) {
  return useReducer(basicStateReducer, // useReducer has a special case to support lazy useState initializers
  initialState);
}

function useReducer(reducer, initialArg, init) {
  var id = getCurrentIdentity();
  workInProgressHook = createWorkInProgressHook();

  if (isReRender) {
    // This is a re-render. Apply the new render phase updates to the previous
    // current hook.
    var queue = workInProgressHook.queue;
    var dispatch = queue.dispatch;

    if (renderPhaseUpdates !== null) {
      // Render phase updates are stored in a map of queue -> linked list
      var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

      if (firstRenderPhaseUpdate !== undefined) {
        renderPhaseUpdates.delete(queue);
        var newState = workInProgressHook.memoizedState;
        var update = firstRenderPhaseUpdate;

        do {
          // Process this render phase update. We don't have to check the
          // priority because it will always be the same as the current
          // render's.
          var action = update.action;
          newState = reducer(newState, action);
          update = update.next;
        } while (update !== null);

        workInProgressHook.memoizedState = newState;
        return [newState, dispatch];
      }
    }

    return [workInProgressHook.memoizedState, dispatch];
  } else {
    var initialState;

    if (reducer === basicStateReducer) {
      // Special case for `useState`.
      initialState = typeof initialArg === 'function' ? initialArg() : initialArg;
    } else {
      initialState = init !== undefined ? init(initialArg) : initialArg;
    }

    workInProgressHook.memoizedState = initialState;
    var queue$1 = workInProgressHook.queue = {
      last: null,
      dispatch: null
    };
    var dispatch$1 = queue$1.dispatch = dispatchAction.bind(null, id, queue$1);
    return [workInProgressHook.memoizedState, dispatch$1];
  }
}

function useMemo(nextCreate, deps) {
  getCurrentIdentity();
  workInProgressHook = createWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;

  if (workInProgressHook !== null) {
    var prevState = workInProgressHook.memoizedState;

    if (prevState !== null) {
      if (nextDeps !== null) {
        var prevDeps = prevState[1];

        if (areHookInputsEqual(nextDeps, prevDeps)) {
          return prevState[0];
        }
      }
    }
  }

  var nextValue = nextCreate();
  workInProgressHook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function useRef(initialValue) {
  getCurrentIdentity();
  workInProgressHook = createWorkInProgressHook();
  var previousRef = workInProgressHook.memoizedState;

  if (previousRef === null) {
    var ref = {
      current: initialValue
    };
    workInProgressHook.memoizedState = ref;
    return ref;
  } else {
    return previousRef;
  }
}

function dispatchAction(componentIdentity, queue, action) {
  if (componentIdentity === getCurrentIdentity()) {
    // This is a render phase update. Stash it in a lazily-created map of
    // queue -> linked list of updates. After this render pass, we'll restart
    // and apply the stashed updates on top of the work-in-progress hook.
    didScheduleRenderPhaseUpdate = true;
    var update = {
      action: action,
      next: null
    };

    if (renderPhaseUpdates === null) {
      renderPhaseUpdates = new Map();
    }

    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

    if (firstRenderPhaseUpdate === undefined) {
      renderPhaseUpdates.set(queue, update);
    } else {
      // Append the update to the end of the list.
      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;

      while (lastRenderPhaseUpdate.next !== null) {
        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      }

      lastRenderPhaseUpdate.next = update;
    }
  }
}

function useCallback(callback, deps) {
  // Callbacks are passed as they are in the server environment.
  return callback;
}

function noop() {}

var Dispatcher = {
  readContext: readContext,
  useContext: useContext,
  useMemo: useMemo,
  useReducer: useReducer,
  useRef: useRef,
  useState: useState,
  useCallback: useCallback,
  // ignore useLayout effect completely as usage of it will be caught
  // in a subsequent render pass
  useLayoutEffect: noop,
  // useImperativeHandle is not run in the server environment
  useImperativeHandle: noop,
  // Effects are not run in the server environment.
  useEffect: noop,
  // Debugging effect
  useDebugValue: noop
};

//

// 

var resolve = function (type) {
  type._status = 0;
  /* PENDING */

  return type._ctor().then(function (Component) {
    if (typeof Component === 'function') {
      type._result = Component;
      type._status = 1;
      /* SUCCESSFUL */
    } else if (Component !== null && typeof Component === 'object' && typeof Component.default === 'function') {
      type._result = Component.default;
      type._status = 1;
      /* SUCCESSFUL */
    } else {
      type._status = 2;
      /* FAILED */
    }
  }).catch(function () {
    type._status = 2;
    /* FAILED */
  });
};

var render = function (type, props, queue) {
  // Component has previously been fetched successfully,
  // so create the element with passed props and return it
  if (type._status === 1) {
    return React.createElement(type._result, props);
  }

  return null;
};

var mount = function (type, props, queue) {
  // If the component has not been fetched yet, suspend this component
  if (type._status !== 2 && type._status !== 1) {
    queue.push({
      contextMap: getCurrentContextMap(),
      contextStore: getCurrentContextStore(),
      kind: 'frame.lazy',
      thenable: resolve(type),
      props: props,
      type: type
    });
    return null;
  }

  return render(type, props, queue);
};
var update = function (queue, frame) {
  setCurrentIdentity(null);
  setCurrentContextMap(frame.contextMap);
  setCurrentContextStore(frame.contextStore);
  return render(frame.type, frame.props, queue);
};

// 

var makeFrame = function (type, props, thenable) { return ({
  contextMap: getCurrentContextMap(),
  contextStore: getCurrentContextStore(),
  id: getCurrentIdentity(),
  hook: getFirstHook(),
  kind: 'frame.hooks',
  thenable: thenable,
  props: props,
  type: type
}); };

var render$1 = function (type, props, queue) {
  try {
    return renderWithHooks(type, computeProps(props, type.defaultProps), maskContext(type));
  } catch (error) {
    if (typeof error.then !== 'function') {
      throw error;
    }

    queue.push(makeFrame(type, props, error));
    return null;
  } finally {
    setCurrentIdentity(null);
  }
};
/** Mount a function component */


var mount$1 = function (type, props, queue, visitor, element) {
  setFirstHook(null);
  setCurrentIdentity(makeIdentity());

  if (element !== undefined) {
    var p = visitor(element);

    if (typeof p === 'object' && p !== null && typeof p.then === 'function') {
      queue.push(makeFrame(type, props, p));
      return null;
    }
  }

  return render$1(type, props, queue);
};
/** Update a previously suspended function component */

var update$1 = function (queue, frame) {
  setFirstHook(frame.hook);
  setCurrentIdentity(frame.id);
  setCurrentContextMap(frame.contextMap);
  setCurrentContextStore(frame.contextStore);
  return render$1(frame.type, frame.props, queue);
};

// 

var createUpdater = function () {
  var queue = [];
  return {
    queue: queue,
    isMounted: function () { return false; },
    enqueueForceUpdate: function () { return null; },
    enqueueReplaceState: function (instance, completeState) {
      if (instance._isMounted) {
        queue.length = 0;
        queue.push(completeState);
      }
    },
    enqueueSetState: function (instance, currentPartialState) {
      if (instance._isMounted) {
        queue.push(currentPartialState);
      }
    }
  };
};

var flushEnqueuedState = function (instance) {
  var queue = instance.updater.queue;

  if (queue.length > 0) {
    var nextState = Object.assign({}, instance.state);

    for (var i = 0, l = queue.length; i < l; i++) {
      var partial = queue[i];
      var partialState = typeof partial === 'function' ? partial.call(instance, nextState, instance.props, instance.context) : partial;

      if (partialState !== null) {
        Object.assign(nextState, partialState);
      }
    }

    instance.state = nextState;
    queue.length = 0;
  }
};

var createInstance = function (type, props) {
  var updater = createUpdater();
  var computedProps = computeProps(props, type.defaultProps);
  var context = maskContext(type);
  var instance = new type(computedProps, context, updater);
  instance.props = computedProps;
  instance.context = context;
  instance.updater = updater;
  instance._isMounted = true;

  if (instance.state === undefined) {
    instance.state = null;
  }

  if (typeof type.getDerivedStateFromProps === 'function') {
    var getDerivedStateFromProps = type.getDerivedStateFromProps;
    var state = getDerivedStateFromProps(instance.props, instance.state);

    if (state !== null && state !== undefined) {
      instance.state = Object.assign({}, instance.state, state);
    }
  } else if (typeof instance.componentWillMount === 'function') {
    instance.componentWillMount();
  } else if (typeof instance.UNSAFE_componentWillMount === 'function') {
    instance.UNSAFE_componentWillMount();
  }

  return instance;
};

var makeFrame$1 = function (type, instance, thenable) { return ({
  contextMap: getCurrentContextMap(),
  contextStore: getCurrentContextStore(),
  thenable: thenable,
  kind: 'frame.class',
  instance: instance,
  type: type
}); };

var render$2 = function (type, instance, queue) {
  // Flush all queued up state changes
  flushEnqueuedState(instance);
  var child = null;

  try {
    child = instance.render();
  } catch (error) {
    if (typeof error.then !== 'function') {
      throw error;
    }

    queue.push(makeFrame$1(type, instance, error));
    return null;
  }

  if (type.childContextTypes !== undefined && typeof instance.getChildContext === 'function') {
    var childContext = instance.getChildContext();

    if (childContext !== null && typeof childContext === 'object') {
      assignContextMap(childContext);
    }
  }

  if (typeof instance.getDerivedStateFromProps !== 'function' && (typeof instance.componentWillMount === 'function' || typeof instance.UNSAFE_componentWillMount === 'function') && typeof instance.componentWillUnmount === 'function') {
    try {
      instance.componentWillUnmount();
    } catch (_err) {}
  }

  instance._isMounted = false;
  return child;
};
/** Mount a class component */


var mount$2 = function (type, props, queue, visitor, element) {
  setCurrentIdentity(null);
  var instance = createInstance(type, props);

  if (element !== undefined) {
    var p = visitor(element, instance);

    if (typeof p === 'object' && p !== null && typeof p.then === 'function') {
      queue.push(makeFrame$1(type, instance, p));
      return null;
    }
  }

  return render$2(type, instance, queue);
};
/** Update a previously suspended class component */

var update$2 = function (queue, frame) {
  setCurrentIdentity(null);
  setCurrentContextMap(frame.contextMap);
  setCurrentContextStore(frame.contextStore);
  return render$2(frame.type, frame.instance, queue);
};

//

// 

var render$3 = function (type, props, queue, visitor, element) {
  return shouldConstruct(type) ? mount$2(type, props, queue, visitor, element) : mount$1(type, props, queue, visitor, element);
};

var visitElement = function (element, queue, visitor) {
  switch (typeOf(element)) {
    case REACT_SUSPENSE_TYPE:
    case REACT_STRICT_MODE_TYPE:
    case REACT_CONCURRENT_MODE_TYPE:
    case REACT_PROFILER_TYPE:
    case REACT_FRAGMENT_TYPE:
      {
        // These element types are simply traversed over but otherwise ignored
        var fragmentElement = element;
        return getChildrenArray(fragmentElement.props.children);
      }

    case REACT_PROVIDER_TYPE:
      {
        var providerElement = element; // Add provider's value prop to context

        var ref = providerElement.props;
        var value = ref.value;
        var children = ref.children;
        setContextValue(providerElement.type._context, value);
        return getChildrenArray(children);
      }

    case REACT_CONTEXT_TYPE:
      {
        var consumerElement = element;
        var ref$1 = consumerElement.props;
        var children$1 = ref$1.children; // Read from context and call children, if it's been passed

        if (typeof children$1 === 'function') {
          var type = consumerElement.type;
          var context = typeof type._context === 'object' ? type._context : type;
          var value$1 = readContextValue(context);
          return getChildrenArray(children$1(value$1));
        } else {
          return [];
        }
      }

    case REACT_LAZY_TYPE:
      {
        var lazyElement = element;
        var type$1 = lazyElement.type;
        var child = mount(type$1, lazyElement.props, queue);
        return getChildrenArray(child);
      }

    case REACT_MEMO_TYPE:
      {
        var memoElement = element;
        var type$2 = memoElement.type.type;
        var child$1 = render$3(type$2, memoElement.props, queue, visitor);
        return getChildrenArray(child$1);
      }

    case REACT_FORWARD_REF_TYPE:
      {
        var refElement = element; // Treat inner type as the component instead of React.forwardRef itself

        var type$3 = refElement.type.render;
        var props = refElement.props;
        var child$2 = mount$1(type$3, props, queue, visitor);
        return getChildrenArray(child$2);
      }

    case REACT_ELEMENT_TYPE:
      {
        var el = element;

        if (typeof el.type === 'string') {
          // String elements can be skipped, so we just return children
          return getChildrenArray(el.props.children);
        } else {
          var userElement = element;
          var type$4 = userElement.type;
          var props$1 = userElement.props;
          var child$3 = render$3(type$4, props$1, queue, visitor, userElement);
          return getChildrenArray(child$3);
        }
      }

    case REACT_PORTAL_TYPE: // Portals are unsupported during SSR since they're DOM-only

    default:
      return [];
  }
};

var visitChild = function (child, queue, visitor) {
  var children = visitElement(child, queue, visitor); // Flush the context changes

  var prevMap = flushPrevContextMap();
  var prevStore = flushPrevContextStore();
  visitChildren(children, queue, visitor); // Restore context changes after children have been walked

  if (prevMap !== undefined) {
    restoreContextMap(prevMap);
  }

  if (prevStore !== undefined) {
    restoreContextStore(prevStore);
  }
};

var visitChildren = function (children, queue, visitor) {
  for (var i = 0, l = children.length; i < l; i++) {
    visitChild(children[i], queue, visitor);
  }
};

// 
var ref = React__default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
var ReactCurrentDispatcher = ref.ReactCurrentDispatcher;
var prevDispatcher = ReactCurrentDispatcher.current;

var flushFrames = function (queue, visitor) {
  if (queue.length === 0) {
    return Promise.resolve();
  }

  var frame = queue.shift();
  return frame.thenable.then(function () {
    prevDispatcher = ReactCurrentDispatcher.current;
    ReactCurrentDispatcher.current = Dispatcher;
    var children = [];

    if (frame.kind === 'frame.class') {
      children = getChildrenArray(update$2(queue, frame));
    } else if (frame.kind === 'frame.hooks') {
      children = getChildrenArray(update$1(queue, frame));
    } else if (frame.kind === 'frame.lazy') {
      children = getChildrenArray(update(queue, frame));
    }

    visitChildren(children, queue, visitor);
    ReactCurrentDispatcher.current = prevDispatcher;
    return flushFrames(queue, visitor);
  });
};

var defaultVisitor = function () {};

var renderPrepass = function (element, visitor) {
  var queue = [];
  var fn = visitor !== undefined ? visitor : defaultVisitor;
  setCurrentContextMap({});
  setCurrentContextStore(new Map());

  try {
    prevDispatcher = ReactCurrentDispatcher.current;
    ReactCurrentDispatcher.current = Dispatcher;
    visitChildren(getChildrenArray(element), queue, fn);
  } catch (error) {
    return Promise.reject(error);
  } finally {
    ReactCurrentDispatcher.current = prevDispatcher;
  }

  return flushFrames(queue, fn);
};

module.exports = renderPrepass;
//# sourceMappingURL=react-ssr-prepass.development.js.map
