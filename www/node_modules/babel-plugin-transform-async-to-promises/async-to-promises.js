"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var fs_1 = require("fs");
var path_1 = require("path");
var defaultConfigValues = {
    externalHelpers: false,
    hoist: false,
    inlineHelpers: false,
    minify: false,
    target: "es5"
};
function readConfigKey(config, key) {
    if (Object.hasOwnProperty.call(config, key)) {
        var result = config[key];
        if (typeof result !== "undefined") {
            return result;
        }
    }
    return defaultConfigValues[key];
}
var constantFunctionMethods = {
    "call": false,
    "apply": false,
    "bind": false
};
var constantStaticMethods = {
    "Object": __assign({ "assign": true, "create": true, "defineProperty": true, "defineProperties": true, "entries": true, "freeze": true, "fromEntries": true, "getOwnPropertyDescriptor": true, "getOwnPropertyDescriptors": true, "getOwnPropertyNames": true, "getOwnPropertySymbols": true, "getPrototypeOf": true, "is": true, "isExtensible": true, "isFrozen": true, "isSealed": true, "keys": true, "preventExtensions": true, "seal": true, "setPrototypeOf": true, "values": true }, constantFunctionMethods),
    "Function": constantFunctionMethods,
    "Boolean": constantFunctionMethods,
    "Number": __assign({ "isNaN": true, "isFinite": true, "isInteger": true, "isSafeInteger": true, "parseFloat": true, "parseInteger": true }, constantFunctionMethods),
    "Array": __assign({ "from": true, "isArray": true, "of": true }, constantFunctionMethods),
    "Date": __assign({ "now": true, "parse": true, "UTC": true }, constantFunctionMethods),
    "RegExp": constantFunctionMethods,
    "Error": constantFunctionMethods,
    "TypeError": constantFunctionMethods,
    "Map": constantFunctionMethods,
    "Set": constantFunctionMethods,
    "WeakMap": constantFunctionMethods,
    "WeakSet": constantFunctionMethods,
    "Promise": __assign({ "all": true, "race": true, "resolve": true, "reject": true }, constantFunctionMethods),
    "Math": {
        "abs": true,
        "acos": true,
        "asin": true,
        "atan": true,
        "atan2": true,
        "ceil": true,
        "cos": true,
        "exp": true,
        "floor": true,
        "log": true,
        "max": true,
        "min": true,
        "pow": true,
        "random": true,
        "round": true,
        "sin": true,
        "sqrt": true,
        "tan": true
    },
    "JSON": {
        "parse": true,
        "stringify": true
    },
    "URL": __assign({ "createObjectURL": true, "revokeObjectURL": true }, constantFunctionMethods),
    "console": {
        "assert": true,
        "clear": true,
        "count": true,
        "error": true,
        "info": true,
        "log": true,
        "warn": true
    },
    "document": {
        "createComment": true,
        "createElement": true,
        "createTextNode": true,
        "getElementsByClassName": true,
        "getElementsByTagName": true,
        "getElementsByName": true,
        "getElementById": true,
        "querySelector": true,
        "querySelectorAll": true,
        "write": true,
        "writeln": true
    },
    "XMLHttpRequest": constantFunctionMethods,
    "WebSocket": constantFunctionMethods,
    "Image": constantFunctionMethods,
    "alert": constantFunctionMethods,
    "confirm": constantFunctionMethods,
    "open": constantFunctionMethods,
    "prompt": constantFunctionMethods,
    "eval": constantFunctionMethods,
    "isFinite": constantFunctionMethods,
    "isNaN": constantFunctionMethods,
    "parseInt": constantFunctionMethods,
    "parseFloat": constantFunctionMethods,
    "decodeURI": constantFunctionMethods,
    "decodeURIComponent": constantFunctionMethods,
    "encodeURI": constantFunctionMethods,
    "encodeURIComponent": constantFunctionMethods,
    "escape": constantFunctionMethods,
    "unescape": constantFunctionMethods,
    "$": constantFunctionMethods
};
;
var errorOnIncompatible = true;
;
var helpers;
var alwaysTruthy = Object.keys(constantStaticMethods);
var numberNames = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
// Main function, called by babel with module implementations for types, template, traverse, transformFromAST and its version information
function default_1(_a) {
    var types = _a.types, template = _a.template, traverse = _a.traverse, transformFromAst = _a.transformFromAst, version = _a.version;
    var isNewBabel = !/^6\./.test(version);
    function cloneNode(node) {
        var result = types.cloneDeep(node);
        if ((node.type == "Identifier" || node.type == "MemberExpression") && node.hasOwnProperty("_helperName")) {
            result._helperName = node._helperName;
        }
        return result;
    }
    // Helper to wrap a node in a statement so it can be used by functions that require a statement
    function wrapNodeInStatement(node) {
        if (types.isStatement(node)) {
            return types.blockStatement([node]);
        }
        if (types.isExpression(node)) {
            return types.expressionStatement(node);
        }
        throw new Error("Expected either an expression or a statement, got a " + node.type + "!");
    }
    // Helper to wrap a fresh node in a path so that it can be traversed
    function pathForNewNode(node, parentPath) {
        var contextPath = parentPath;
        while (!contextPath.context) {
            contextPath = contextPath.parentPath;
            if (contextPath === null) {
                throw parentPath.buildCodeFrameError("Unable to find a context upon which to traverse!", TypeError);
            }
        }
        var result = contextPath.context.create(parentPath.node, [node], 0, "dummy");
        result.setContext(contextPath.context);
        return result;
    }
    // Checks whether nodes pass a test
    function pathsPassTest(matchingNodeTest, referenceOriginalNodes) {
        function visit(path, result, state) {
            if (referenceOriginalNodes) {
                var originalNode = path.node._originalNode;
                if (originalNode) {
                    traverse(wrapNodeInStatement(originalNode), visitor, path.scope, { match: result, state: state }, path);
                    return false;
                }
            }
            var doesMatch = matchingNodeTest(path);
            if (doesMatch) {
                result.any = true;
                result.all = !(state.breakingLabels.length || state.unnamedBreak);
                // result.paths.push(path);
            }
            if (path.isBreakStatement()) {
                var label = path.node.label;
                if (!label) {
                    state.unnamedBreak = true;
                }
                else if (state.breakingLabels.indexOf(label.name) === -1) {
                    state.breakingLabels.push(label.name);
                }
            }
            if (path.isLabeledStatement()) {
                var index = state.breakingLabels.indexOf(path.node.label.name);
                if (index !== -1) {
                    state.breakingLabels.splice(index, 1);
                }
            }
            if (path.isLoop()) {
                state.unnamedBreak = false;
            }
            if (doesMatch) {
                return false;
            }
            if (path.isConditional()) {
                var test = match(path.get("test"), state);
                var consequent = match(path.get("consequent"), state);
                var alternate = match(path.get("alternate"), state);
                result.any = result.any || test.any || consequent.any || alternate.any;
                // result.paths = result.paths.concat(test.paths).concat(consequent.paths).concat(alternate.paths);
                return (result.all = (test.all || (consequent.all && alternate.all)) && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isSwitchStatement()) {
                var discriminant = match(path.get("discriminant"), state);
                var cases_1 = path.get("cases");
                var caseMatches = cases_1.map(function (switchCase, i) {
                    var newState = { unnamedBreak: false, breakingLabels: state.breakingLabels };
                    var newResult = match(switchCase, newState);
                    for (i++; (!newResult.all || pathsBreakReturnOrThrow(switchCase).all) && i < cases_1.length; i++) {
                        var tailMatch = match(cases_1[i], newState);
                        newResult.all = (newResult.all || tailMatch.all) && !(state.breakingLabels.length || state.unnamedBreak);
                        newResult.any = newResult.any || tailMatch.any;
                        // newResult.paths = newResult.paths.concat(tailMatch.paths);
                    }
                    return newResult;
                });
                result.any = result.any || discriminant.any || caseMatches.some(function (caseMatch) { return caseMatch.any; });
                // result.paths = caseMatches.reduce((acc, match) => acc.concat(match.paths), result.paths.concat(discriminant.paths));
                return result.all = ((discriminant.all || (cases_1.some(function (switchCase) { return !switchCase.node.test; }) && caseMatches.every(function (caseMatch) { return caseMatch.all; }))) && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isDoWhileStatement()) {
                var body = match(path.get("body"), { unnamedBreak: false, breakingLabels: state.breakingLabels });
                var test = match(path.get("test"), state);
                result.any = result.any || body.any || test.any;
                // result.paths = result.paths.concat(test.paths).concat(body.paths);
                return result.all = ((body.all || test.all) && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isWhileStatement()) {
                // TODO: Support detecting break/return statements
                var testPath = path.get("test");
                var test = match(testPath, state);
                var body = match(path.get("body"), { unnamedBreak: false, breakingLabels: state.breakingLabels });
                result.any = result.any || test.any || body.any;
                // result.paths = result.paths.concat(test.paths).concat(body.paths);
                return result.all = ((test.all || (body.all && (extractLooseBooleanValue(testPath.node) === true))) && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isForXStatement()) {
                var right = match(path.get("right"), state);
                var body = match(path.get("body"), { unnamedBreak: false, breakingLabels: state.breakingLabels });
                result.any = result.any || right.any || body.any;
                // result.paths = result.paths.concat(right.paths).concat(body.paths);
                return result.all = (right.all && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isForStatement()) {
                var init = match(path.get("init"), state);
                var test = match(path.get("test"), state);
                var body = match(path.get("body"), { unnamedBreak: false, breakingLabels: state.breakingLabels });
                var update = match(path.get("update"), state);
                result.any = result.any || init.any || test.any || body.any || update.any;
                // result.paths = result.paths.concat(init.paths).concat(test.paths).concat(update.paths).concat(body.paths);
                return result.all = ((init.all || test.all) && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isLogicalExpression()) {
                var left = match(path.get("left"), state);
                var right = match(path.get("right"), state);
                result.any = result.any || left.any || right.any;
                // result.paths = result.paths.concat(left.paths).concat(right.paths);
                return result.all = (left.all && !(state.breakingLabels.length || state.unnamedBreak));
            }
            if (path.isReturnStatement()) {
                return true;
            }
            if (path.isBreakStatement()) {
                return true;
            }
            if (path.isContinueStatement()) {
                return true;
            }
            if (path.isThrowStatement()) {
                // TODO: Handle throw statements correctly
                return true;
            }
            if (path.isTryStatement()) {
                var blockMatch = match(path.get("block"), state);
                var finalizer = path.get("finalizer");
                var finalizerMatch = match(finalizer, state);
                var handler = path.get("handler");
                var handlerMatch = match(handler, state);
                result.any = result.any || blockMatch.any || handlerMatch.any || finalizerMatch.any;
                // result.paths = result.paths.concat(blockMatch.paths).concat(handlerMatch.paths).concat(finalizerMatch.paths);
                if (finalizerMatch.all) {
                    return result.all = !(state.breakingLabels.length || state.unnamedBreak);
                }
                else if (!finalizer.node) {
                    return result.all = (handlerMatch.all && blockMatch.all && !(state.breakingLabels.length || state.unnamedBreak));
                }
                return false;
            }
            if (path.isFunction()) {
                return false;
            }
        }
        var visitor = {
            enter: function (path) {
                switch (visit(path, this.match, this.state)) {
                    case true:
                        path.stop();
                        break;
                    case false:
                        path.skip();
                        break;
                }
            }
        };
        function match(path, state) {
            var match = { all: false, any: false };
            if (path && path.node) {
                if (typeof visit(path, match, state) === "undefined") {
                    path.traverse(visitor, { match: match, state: state });
                }
            }
            return match;
        }
        return function (path) { return match(path, { breakingLabels: [], unnamedBreak: false }); };
    }
    function pathsReachNodeTypes(matchingNodeTypes, referenceOriginalNodes) {
        return pathsPassTest(function (path) { return path.type !== null && matchingNodeTypes.indexOf(path.type) !== -1; }, referenceOriginalNodes);
    }
    // Helpers to trace return, throw and break behaviours
    var pathsReturnOrThrow = pathsReachNodeTypes(["ReturnStatement", "ThrowStatement"], true);
    var pathsReturnOrThrowCurrentNodes = pathsReachNodeTypes(["ReturnStatement", "ThrowStatement"], false);
    var pathsBreak = pathsReachNodeTypes(["BreakStatement"], true);
    var pathsBreakReturnOrThrow = pathsReachNodeTypes(["ReturnStatement", "ThrowStatement", "BreakStatement"], true);
    function isNonEmptyStatement(statement) {
        return !types.isEmptyStatement(statement);
    }
    // Extract a single return expression
    function expressionInSingleReturnStatement(target) {
        var body = target.body;
        if (types.isBlockStatement(body)) {
            var statements = body.body.filter(isNonEmptyStatement);
            if (statements.length === 0) {
                return voidExpression();
            }
            else {
                var firstStatement = statements[0];
                if (types.isReturnStatement(firstStatement)) {
                    return firstStatement.argument || voidExpression();
                }
            }
        }
        else {
            return body;
        }
    }
    // Extract the static property of a member expression, if possible
    function propertyNameOfMemberExpression(node) {
        var property = node.property;
        if (node.computed) {
            if (types.isStringLiteral(property)) {
                return property.value;
            }
        }
        else {
            if (types.isIdentifier(property)) {
                return property.name;
            }
        }
    }
    // Match a for (var i = 0; i < array.length; i++) pattern
    function identifiersInForToLengthStatement(statement) {
        // Match: for (var i = 0; i < array.length; i++)
        var init = statement.get("init");
        if (init.isVariableDeclaration() && init.node.declarations.length === 1) {
            var declaration = init.get("declarations")[0];
            if (types.isNumericLiteral(declaration.node.init) && declaration.node.init.value === 0) {
                var i = declaration.node.id;
                var test = statement.get("test");
                if (types.isIdentifier(i) &&
                    test.isBinaryExpression() &&
                    test.node.operator === "<" &&
                    types.isIdentifier(test.node.left) &&
                    test.node.left.name === i.name) {
                    var right = test.get("right");
                    if (right.isMemberExpression()) {
                        var object = right.node.object;
                        if (types.isIdentifier(object) &&
                            propertyNameOfMemberExpression(right.node) === "length") {
                            var update_1 = statement.get("update");
                            if (update_1.isUpdateExpression() &&
                                update_1.node.operator == "++" &&
                                types.isIdentifier(update_1.node.argument) &&
                                update_1.node.argument.name === i.name) {
                                var binding = statement.scope.getBinding(i.name);
                                if (binding) {
                                    var updateArgument_1 = update_1.get("argument");
                                    if (!binding.constantViolations.some(function (cv) { return cv !== updateArgument_1 && cv !== update_1; })) {
                                        return {
                                            i: i,
                                            array: object
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // Extract a for (var key of obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { ... } } pattern
    function extractForOwnBodyPath(path) {
        // Match: for (var key of obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { ... } }
        var left = path.get("left");
        if (left.isVariableDeclaration()) {
            left = left.get("declarations")[0].get("id");
        }
        var right = path.get("right");
        // Check to see if we have a simple for of statement with two variables
        if (left.isIdentifier() && right.isIdentifier()) {
            var rightBinding = path.scope.getBinding(right.node.name);
            if (rightBinding && rightBinding.constant) {
                var body = path.get("body");
                for (;;) {
                    var statements = void 0;
                    if (body.isBlockStatement()) {
                        statements = body.get("body");
                    }
                    else if (body.isReturnStatement()) {
                        var argument = body.get("argument");
                        if (argument.isCallExpression() && invokeTypeOfExpression(argument) && argument.get("arguments").length === 1) {
                            var firstArgument = argument.get("arguments")[0];
                            if (firstArgument.isFunctionExpression()) {
                                statements = firstArgument.get("body").get("body");
                            }
                            else {
                                break;
                            }
                        }
                        else {
                            break;
                        }
                    }
                    else {
                        break;
                    }
                    if (statements.length !== 1) {
                        return;
                    }
                    body = statements[0];
                }
                // Check for an if statement with a single call expression
                if (body.isIfStatement() && !body.node.alternate) {
                    var test = body.get("test");
                    if (test.isCallExpression() && test.node.arguments.length === 2) {
                        var args = test.get("arguments");
                        // Check that call arguments match the key and target variables
                        var firstArg = args[0];
                        var secondArg = args[1];
                        if (firstArg.isIdentifier() && firstArg.node.name === right.node.name &&
                            secondArg.isIdentifier() && secondArg.node.name === left.node.name) {
                            // Check for .call(...)
                            var callee = test.get("callee");
                            if (callee.isMemberExpression() && propertyNameOfMemberExpression(callee.node) === "call") {
                                // Check for .hasOwnProperty
                                var method = callee.get("object");
                                if (method.isMemberExpression() && propertyNameOfMemberExpression(method.node) === "hasOwnProperty") {
                                    var target = method.get("object");
                                    // Check for empty temporary object
                                    if (target.isObjectExpression() && target.node.properties.length === 0) {
                                        return body.get("consequent");
                                    }
                                    // Strip .prototype if present
                                    if (target.isMemberExpression() && propertyNameOfMemberExpression(target.node) === "prototype") {
                                        target = target.get("object");
                                    }
                                    // Check for Object
                                    if (target.isIdentifier() && target.node.name === "Object") {
                                        return body.get("consequent");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    function isContinuation(possible) {
        return (types.isFunctionExpression(possible) && possible.id === null) || types.isArrowFunctionExpression(possible);
    }
    // Check if a function expression always returns its first argument, with no side effects
    function isPassthroughContinuation(continuation) {
        if (continuation) {
            if (isContinuation(continuation) && continuation.params.length === 1) {
                var expression = expressionInSingleReturnStatement(continuation);
                if (expression) {
                    var firstParam = continuation.params[0];
                    if (types.isIdentifier(firstParam)) {
                        var valueName = firstParam.name;
                        if (types.isIdentifier(expression) && expression.name === valueName) {
                            return true;
                        }
                        if (types.isConditionalExpression(expression) && types.isIdentifier(expression.test) && types.isIdentifier(expression.consequent) && expression.consequent.name === valueName && types.isIdentifier(expression.alternate) && expression.alternate.name === valueName) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    // Check if an expression is a function that returns undefined and has no side effects or is a reference to the _empty helper
    function isEmptyContinuation(continuation, path) {
        if (types.isIdentifier(continuation)) {
            return continuation._helperName === "_empty";
        }
        if (isContinuation(continuation)) {
            var body = continuation.body;
            if (types.isBlockStatement(body)) {
                return body.body.length === 0;
            }
        }
        return false;
    }
    // Emit a void expression
    function voidExpression(arg) {
        return types.unaryExpression("void", arg || types.numericLiteral(0));
    }
    // Simplify an expression with a substituted "truthiness" value for an identifier
    function simplifyWithIdentifier(expression, identifier, truthy) {
        if (types.isCallExpression(expression)) {
            switch (promiseCallExpressionType(expression)) {
                case "all":
                case "race":
                case "reject":
                case "resolve": {
                    var firstArgument = expression.arguments[0];
                    if (typeof firstArgument !== "undefined" && !types.isSpreadElement(firstArgument)) {
                        var simplified = simplifyWithIdentifier(firstArgument, identifier, truthy);
                        return simplified === expression.arguments[0] ? expression : types.callExpression(expression.callee, [simplified]);
                    }
                }
                case "then": {
                    var callee = expression.callee;
                    if (types.isMemberExpression(callee)) {
                        var thenArgument = expression.arguments[0];
                        var object = callee.object;
                        if (types.isCallExpression(object)) {
                            var valueArgument = object.arguments[0];
                            if (typeof valueArgument !== "undefined" && !types.isSpreadElement(valueArgument) && typeof thenArgument !== "undefined" && !types.isSpreadElement(thenArgument)) {
                                var simplified = simplifyWithIdentifier(valueArgument, identifier, truthy);
                                return simplified === valueArgument ? expression : callThenMethod(types.callExpression(object.callee, [simplified]), thenArgument);
                            }
                        }
                    }
                }
            }
            if (expression.arguments.length === 1 && types.isIdentifier(expression.callee) || isContinuation(expression.callee)) {
                var firstArgument = expression.arguments[0];
                if (types.isExpression(firstArgument)) {
                    var simplified = simplifyWithIdentifier(firstArgument, identifier, truthy);
                    return simplified === expression.arguments[0] ? expression : types.callExpression(expression.callee, [simplified]);
                }
            }
        }
        if (types.isConditionalExpression(expression) && types.isIdentifier(expression.test) && expression.test.name === identifier.name) {
            return truthy ? expression.consequent : expression.alternate;
        }
        if (types.isLogicalExpression(expression) && types.isIdentifier(expression.left) && expression.left.name === identifier.name) {
            if (expression.operator === "&&") {
                return truthy ? expression.right : expression.left;
            }
            if (expression.operator === "||") {
                return truthy ? expression.left : expression.right;
            }
        }
        return expression;
    }
    // Checks if an expression is an identifier or a literal
    function isIdentifierOrLiteral(expression) {
        return types.isIdentifier(expression) || types.isLiteral(expression);
    }
    // Extract a "simple" expression out of a continuation; this is to avoid emitting a function declaration for simple continuations that merely return a value
    function simpleExpressionForContinuation(continuation, value) {
        if (isContinuation(continuation)) {
            var expression = expressionInSingleReturnStatement(continuation);
            if (expression) {
                switch (continuation.params.length) {
                    case 0:
                        if ((types.isConditionalExpression(expression) && isIdentifierOrLiteral(expression.test) && isIdentifierOrLiteral(expression.consequent) && isIdentifierOrLiteral(expression.alternate)) ||
                            ((types.isLogicalExpression(expression) || types.isBinaryExpression(expression)) && isIdentifierOrLiteral(expression.left) && isIdentifierOrLiteral(expression.right)) ||
                            (types.isUnaryExpression(expression) && isIdentifierOrLiteral(expression.argument)) ||
                            (types.isCallExpression(expression) && isIdentifierOrLiteral(expression.callee) && expression.arguments.length === 0) ||
                            isIdentifierOrLiteral(expression)) {
                            return expression;
                        }
                        break;
                    case 1: {
                        if (!value) {
                            return;
                        }
                        var firstParam_1 = continuation.params[0];
                        var replace = function (expr) { return types.isIdentifier(firstParam_1) && types.isIdentifier(expr) && expr.name === firstParam_1.name ? value : expr; };
                        if (isIdentifierOrLiteral(expression)) {
                            return replace(expression);
                        }
                        if (types.isConditionalExpression(expression) && isIdentifierOrLiteral(expression.test) && isIdentifierOrLiteral(expression.consequent) && isIdentifierOrLiteral(expression.alternate)) {
                            return types.conditionalExpression(replace(expression.test), replace(expression.consequent), replace(expression.alternate));
                        }
                        if (types.isLogicalExpression(expression) && isIdentifierOrLiteral(expression.left) && isIdentifierOrLiteral(expression.right)) {
                            return types.logicalExpression(expression.operator, replace(expression.left), replace(expression.right));
                        }
                        if (types.isBinaryExpression(expression) && isIdentifierOrLiteral(expression.left) && isIdentifierOrLiteral(expression.right)) {
                            return types.binaryExpression(expression.operator, replace(expression.left), replace(expression.right));
                        }
                        if (types.isCallExpression(expression) && isIdentifierOrLiteral(expression.callee) && expression.arguments.length === 0) {
                            return types.callExpression(replace(expression.callee), expression.arguments);
                        }
                    }
                }
            }
        }
    }
    // Await an expression and resume control flow to the continuation, optionally calling directly
    function awaitAndContinue(state, path, value, continuation, directExpression) {
        var declarators = [];
        if (continuation) {
            if (isPassthroughContinuation(continuation)) {
                continuation = undefined;
            }
            else {
                continuation = unwrapReturnCallWithPassthroughArgument(continuation, path.scope);
            }
        }
        if (!continuation && directExpression && extractLooseBooleanValue(directExpression) === true) {
            return {
                declarators: declarators,
                expression: value
            };
        }
        if (types.isCallExpression(value) && value.arguments.length === 0 && isContinuation(value.callee) && value.callee.params.length === 0) {
            var newValue = expressionInSingleReturnStatement(value.callee);
            if (newValue) {
                value = newValue;
            }
        }
        // Directly call .then if the result of a yield statement and there is a continuation to call
        if (continuation && !directExpression && types.isCallExpression(value) && types.isMemberExpression(value.callee) && value.callee._helperName === "_yield") {
            return {
                declarators: declarators,
                expression: callThenMethod(value, continuation)
            };
        }
        // Emit all of the code necessary to call correctly instead of calling helpers
        if (readConfigKey(state.opts, "inlineHelpers")) {
            if (directExpression) {
                var resolvedValue = types.callExpression(promiseResolve(), [value]);
                var direct = extractLooseBooleanValue(directExpression);
                if (typeof direct === "undefined") {
                    // Emit a call to the continuation directly if the direct expression is true, otherwise resolve it and call via then
                    var expression = void 0;
                    if (continuation) {
                        // Store the continuation in a temporary variable if it's complex enough
                        var simpleExpression = void 0;
                        if (!types.isIdentifier(continuation) && !(simpleExpression = simpleExpressionForContinuation(continuation, isIdentifierOrLiteral(value) ? value : undefined))) {
                            var id = path.scope.generateUidIdentifier("temp");
                            if (isContinuation(continuation)) {
                                insertFunctionIntoScope(continuation, id, path.parentPath.scope);
                            }
                            else {
                                declarators.push(types.variableDeclarator(id, continuation));
                            }
                            continuation = id;
                        }
                        expression = conditionalExpression(directExpression, simpleExpression || types.callExpression(continuation, [value]), callThenMethod(resolvedValue, continuation));
                    }
                    else {
                        // No continuation, only wrap the value in a Promise when not direct
                        expression = conditionalExpression(directExpression, value, resolvedValue);
                    }
                    return {
                        declarators: declarators,
                        expression: expression
                    };
                }
                else if (direct) {
                    // Emit a direct call to the continuation
                    return {
                        declarators: declarators,
                        expression: continuation ? types.callExpression(continuation, [value]) : value
                    };
                }
                else {
                    // Emit a call to resolve the value and call the continuation from then
                    return {
                        declarators: declarators,
                        expression: continuation ? callThenMethod(resolvedValue, continuation) : resolvedValue
                    };
                }
            }
            else if (continuation) {
                // Emit a potentially asynhcronous call to the continuation with the result of the value
                var expressions = [];
                if (!types.isIdentifier(value)) {
                    // Return a call to .then on expressions that provably return a Promise
                    if (types.isCallExpression(value) && promiseCallExpressionType(value) !== undefined) {
                        return {
                            declarators: declarators,
                            expression: callThenMethod(value, continuation)
                        };
                    }
                    // Otherwise store in a temporary
                    var id = path.scope.generateUidIdentifier("temp");
                    declarators.push(types.variableDeclarator(id, value));
                    value = id;
                }
                // Store the continuation in a temporary if it's simple
                var isEmpty = isEmptyContinuation(continuation, path);
                var simpleExpression = void 0;
                if (!isEmpty && !types.isIdentifier(continuation) && !(simpleExpression = simpleExpressionForContinuation(continuation, value))) {
                    var id = path.scope.generateUidIdentifier("temp");
                    if (isContinuation(continuation)) {
                        insertFunctionIntoScope(continuation, id, path.parentPath.scope);
                    }
                    else {
                        declarators.push(types.variableDeclarator(id, continuation));
                    }
                    continuation = id;
                }
                // Emit a call to .then if value is thenable, otherwise call the continuation directly
                return {
                    declarators: declarators,
                    expression: types.conditionalExpression(types.logicalExpression("&&", value, types.memberExpression(value, types.identifier("then"))), callThenMethod(value, continuation), simpleExpression ? simpleExpression : (isEmpty ? voidExpression() : types.callExpression(continuation, [value])))
                };
            }
        }
        // Emit calls to helpers
        var callTarget = types.isCallExpression(value) && value.arguments.length === 0 && !types.isMemberExpression(value.callee) ? value.callee : undefined;
        var args = [callTarget || value];
        var ignoreResult = continuation && isEmptyContinuation(continuation, path);
        // Avoid unnecssary arguments to improve code density
        if (!ignoreResult && continuation) {
            args.push(continuation);
        }
        if (directExpression && extractLooseBooleanValue(directExpression) !== false) {
            if (!ignoreResult && !continuation) {
                args.push(voidExpression());
            }
            args.push(directExpression);
        }
        var helperName = directExpression ? (callTarget ? "_call" : "_await") : (callTarget ? "_invoke" : "_continue");
        if (ignoreResult) {
            helperName += "Ignored";
        }
        if (args.length === 1) {
            // Handle a few cases where a helper isn't actually necessary
            switch (helperName) {
                case "_invoke":
                    return {
                        declarators: declarators,
                        expression: types.callExpression(args[0], [])
                    };
                case "_continue":
                    return {
                        declarators: declarators,
                        expression: args[0]
                    };
            }
        }
        // Emit the call to the helper with the arguments
        return {
            declarators: declarators,
            expression: types.callExpression(helperReference(state, path, helperName), args)
        };
    }
    // Borrow the tail continuation of a statement
    function borrowTail(target) {
        var current = target;
        var dest = [];
        while (current && current.node && current.inList && current.container) {
            var siblings = current.getAllNextSiblings();
            for (var _i = 0, siblings_1 = siblings; _i < siblings_1.length; _i++) {
                var sibling = siblings_1[_i];
                sibling.assertStatement();
                dest.push(sibling.node);
            }
            for (var _a = 0, siblings_2 = siblings; _a < siblings_2.length; _a++) {
                var sibling = siblings_2[_a];
                sibling.remove();
            }
            current = current.parentPath;
            if (!current.isBlockStatement()) {
                break;
            }
        }
        return dest;
    }
    // Check if the tail continuation of an expression has a return or throw statement
    function exitsInTail(target) {
        var current = target;
        while (current && current.node && current.inList && current.container && !current.isFunction()) {
            for (var i = current.key + 1; i < current.container.length; i++) {
                var sibling = current.container[current.key + 1];
                if (pathsReturnOrThrow(current).any) {
                    return true;
                }
            }
            current = current.parentPath;
        }
        return false;
    }
    // Emits a return statement, optionally referencing an original node
    function returnStatement(argument, originalNode) {
        var result = types.returnStatement(argument);
        result._skip = true;
        result._originalNode = originalNode;
        return result;
    }
    // Merge unnecessary return statements and prune trailing empty returns
    function removeUnnecessaryReturnStatements(blocks) {
        while (blocks.length) {
            var lastStatement = blocks[blocks.length - 1];
            if (types.isReturnStatement(lastStatement)) {
                if (lastStatement.argument === null || lastStatement.argument === undefined) {
                    blocks = blocks.slice(0, blocks.length - 1);
                }
                else {
                    if (types.isConditionalExpression(lastStatement.argument) && types.isUnaryExpression(lastStatement.argument.alternate) && lastStatement.argument.alternate.operator === "void" && isValueLiteral(lastStatement.argument.alternate.argument)) {
                        blocks = blocks.slice(0, blocks.length - 1);
                        blocks.push(types.ifStatement(lastStatement.argument.test, types.returnStatement(lastStatement.argument.consequent)));
                    }
                    else if (blocks.length > 1) {
                        var previousStatement = blocks[blocks.length - 2];
                        if (types.isIfStatement(previousStatement) && !previousStatement.alternate) {
                            var consequent = previousStatement.consequent;
                            while (types.isBlockStatement(consequent)) {
                                if (consequent.body.length !== 1) {
                                    return blocks;
                                }
                                consequent = consequent.body[0];
                            }
                            if (types.isReturnStatement(consequent) && consequent.argument) {
                                blocks = blocks.slice(0, blocks.length - 2);
                                blocks.push(types.returnStatement(conditionalExpression(previousStatement.test, consequent.argument, lastStatement.argument)));
                            }
                        }
                    }
                    break;
                }
            }
            else {
                if (types.isIfStatement(lastStatement)) {
                    var consequent = lastStatement.consequent;
                    if (types.isBlockStatement(consequent)) {
                        consequent = blockStatement(removeUnnecessaryReturnStatements(consequent.body));
                    }
                    var alternate = lastStatement.alternate;
                    if (alternate) {
                        if (types.isBlockStatement(alternate)) {
                            var removedOfUnnecessary = removeUnnecessaryReturnStatements(alternate.body);
                            alternate = removedOfUnnecessary.length ? blockStatement(removedOfUnnecessary) : undefined;
                        }
                        else if (removeUnnecessaryReturnStatements([alternate]).length === 0) {
                            alternate = undefined;
                        }
                    }
                    if (consequent !== lastStatement.consequent || alternate !== lastStatement.alternate) {
                        blocks = blocks.slice(0, blocks.length - 1);
                        blocks.push(types.ifStatement(lastStatement.test, consequent, alternate || undefined));
                    }
                }
                break;
            }
        }
        return blocks;
    }
    // Rewrite an async node to be explicitly managed continuations split at async expressions
    function rewriteAsyncNode(state, parentPath, node, additionalConstantNames, exitIdentifier, unpromisify) {
        var path = pathForNewNode(node, parentPath);
        rewriteAsyncBlock(state, path, additionalConstantNames, exitIdentifier, unpromisify);
        return path.node;
    }
    // Return the entire stack of scopes for a given scope
    function allScopes(scope) {
        var result = [];
        while (scope) {
            result.push(scope);
            scope = scope.parent;
        }
        return result;
    }
    // Visitor that hoists call arguments
    var hoistCallArgumentsInnerVisitor = {
        Identifier: function (identifierPath) {
            if (identifierSearchesScope(identifierPath)) {
                var name = identifierPath.node.name;
                if (this.argumentNames.indexOf(name) === -1) {
                    if (this.additionalConstantNames.indexOf(name) !== -1) {
                        this.scopes.push(this.path.scope.parent);
                    }
                    else {
                        var binding = identifierPath.scope.getBinding(name);
                        if (binding) {
                            var scope = binding.scope;
                            if (scope !== null) {
                                if (binding.kind === "var" && !binding.path.isFunction()) {
                                    var functionScope = scope.getFunctionParent() || scope.getProgramParent();
                                    if (functionScope !== null) {
                                        scope = functionScope;
                                    }
                                }
                                if (this.pathScopes.indexOf(scope) !== -1) {
                                    this.scopes.push(scope);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    // Check if a node is a literal that has its value on .value
    function isValueLiteral(node) {
        return types.isStringLiteral(node) || types.isNumericLiteral(node) || types.isBooleanLiteral(node);
    }
    // Filter out keys that vary from AST to AST, but don't have observably different behaviour when evaluated
    function keyFilter(key, value) {
        return key === "start" || key === "end" || key === "loc" || key === "directives" || key === "leadingComments" || key === "trailingComments" || key === "innerComments" || key[0] === "_" ? undefined : value;
    }
    // Helper function to check if nodes have equivalent behaviour when evaluated
    function nodesAreEquivalent(node) {
        // Temporary deduping mechanism that filters source locations to see if nodes are otherwise identical
        var cached;
        return function (other) {
            if (typeof cached === "undefined") {
                cached = JSON.stringify(node, keyFilter);
            }
            return cached === JSON.stringify(other, keyFilter);
        };
    }
    // Helper visitor to reregister bindings on demand (working around some bugs in babel's scope tracking)
    var reregisterVariableVisitor = {
        VariableDeclaration: function (path) {
            for (var _i = 0, _a = path.node.declarations; _i < _a.length; _i++) {
                var declarator = _a[_i];
                if (declarator.id.type === "Identifier") {
                    this.originalScope.removeBinding(declarator.id.name);
                }
            }
            path.scope.registerDeclaration(path);
        },
        Function: function (path) {
            path.skip();
        }
    };
    // Inserts a function declaration into a particular scope, abusing the binding system as necessary
    function insertFunctionIntoScope(func, id, scope) {
        // Insert a const declaration containing the function
        scope.push({ kind: "const", id: id, init: func, unique: true });
        // Find the declaration we just inserted
        var binding = scope.getBinding(id.name);
        if (typeof binding === "undefined") {
            /* istanbul ignore next */
            throw scope.path.buildCodeFrameError("Could not find newly created binding for " + id.name + "!", Error);
        }
        // Replace it with a function declaration, because it generates smaller code and we no longer have to worry about const/let ordering issues
        binding.path.parentPath.replaceWith(types.functionDeclaration(id, func.params, types.isBlockStatement(func.body) ? func.body : types.blockStatement([types.returnStatement(func.body)]), func.generator, func.async));
    }
    // Hoist function expressions into a scope where they can be reused
    function hoistFunctionExpressionHandler(path) {
        path.skip();
        var bodyPath = path.get("body");
        if (bodyPath.isBlockStatement() && bodyPath.node.body.length === 0 && !readConfigKey(this.state.opts, "inlineHelpers")) {
            path.replaceWith(emptyFunction(this.state, path));
            return;
        }
        var argumentNames = [];
        for (var _i = 0, _a = path.node.params; _i < _a.length; _i++) {
            var param = _a[_i];
            if (types.isIdentifier(param) || types.isPattern(param) || types.isRestElement(param)) {
                addConstantNames(argumentNames, param);
            }
            else {
                return;
            }
        }
        var scopes = [];
        var pathScopes = allScopes(path.scope.parent);
        path.traverse(hoistCallArgumentsInnerVisitor, {
            argumentNames: argumentNames,
            scopes: scopes,
            pathScopes: pathScopes,
            path: path,
            additionalConstantNames: this.additionalConstantNames
        });
        var scope = path.scope.getProgramParent();
        var ancestry = [scope];
        for (var _b = 0, scopes_1 = scopes; _b < scopes_1.length; _b++) {
            var otherScope = scopes_1[_b];
            if (ancestry.indexOf(otherScope) === -1) {
                scope = otherScope;
                ancestry = ancestry.concat(allScopes(otherScope));
            }
        }
        if (ancestry.indexOf(path.scope.parent) === -1) {
            var bindings = scope.bindings;
            var filter = nodesAreEquivalent(path.node.params.concat([path.node.body]));
            for (var _c = 0, _d = Object.getOwnPropertyNames(bindings); _c < _d.length; _c++) {
                var key = _d[_c];
                var binding = bindings[key];
                var bindingPath = binding.path;
                if (bindingPath.isFunctionDeclaration()) {
                    if (filter(bindingPath.node.params.concat([bindingPath.node.body]))) {
                        path.replaceWith(binding.identifier);
                        return;
                    }
                }
                else if (bindingPath.isVariableDeclarator()) {
                    var init_1 = bindingPath.get("init");
                    if (isContinuation(init_1.node)) {
                        if (filter(init_1.node.params.concat([init_1.node.body]))) {
                            path.replaceWith(binding.identifier);
                            return;
                        }
                    }
                }
            }
            var nameNode = path.node;
            if (types.isExpression(nameNode) && isContinuation(nameNode)) {
                nameNode = nameNode.body;
            }
            if (types.isBlockStatement(nameNode) && nameNode.body.length === 1) {
                nameNode = nameNode.body[0];
            }
            if (types.isReturnStatement(nameNode) && nameNode.argument) {
                nameNode = nameNode.argument;
            }
            if (types.isCallExpression(nameNode)) {
                var callee = nameNode.callee;
                if (types.isIdentifier(callee) && callee._helperName) {
                    nameNode = nameNode.arguments[0];
                }
            }
            var id = isValueLiteral(nameNode) ? scope.generateUidIdentifier(nameNode.value.toString().replace(/\d/g, function (number) { return numberNames[number]; })) : path.scope.generateUidIdentifierBasedOnNode(nameNode, "temp");
            var init = path.node;
            // Replace with the generated ID
            path.replaceWith(id);
            // Insert the function into the scope
            insertFunctionIntoScope(init, id, scope);
        }
    }
    var hoistCallArgumentsVisitor = {
        FunctionExpression: hoistFunctionExpressionHandler,
        ArrowFunctionExpression: hoistFunctionExpressionHandler
    };
    // Hoist the arguments of a call expression, so that additional closures aren't unnecessarily created at runtime
    function hoistCallArguments(state, path, additionalConstantNames) {
        if (path.isCallExpression()) {
            // Workaround problems with babel not detecting scope properly with vars that are relocated
            var functionParent = path.getFunctionParent();
            if (functionParent !== null) {
                functionParent.traverse(reregisterVariableVisitor, { originalScope: path.scope });
            }
            var callee = path.node.callee;
            if ((types.isIdentifier(callee) || types.isMemberExpression(callee)) && callee._helperName) {
                path.traverse(hoistCallArgumentsVisitor, { state: state, additionalConstantNames: additionalConstantNames });
            }
        }
    }
    // Sanity check that a path is still valid and hasn't been removed
    function checkPathValidity(path) {
        if (path.container === null) {
            /* istanbul ignore next */
            throw path.buildCodeFrameError("Path was expected to have a container!", TypeError);
        }
        if ("resync" in path && typeof path.resync === "function") {
            path.resync();
            if (path.container === null) {
                /* istanbul ignore next */
                throw path.buildCodeFrameError("Path was expected to have a container, and lost its container upon resync!", TypeError);
            }
        }
    }
    // Extract the continuation of a path, emit a call to a helper, passing the continuation in as an argument
    function relocateTail(generatorState, awaitExpression, statementNode, target, additionalConstantNames, temporary, exitCheck, directExpression) {
        // Find the tail continuation
        checkPathValidity(target);
        var tail = borrowTail(target);
        checkPathValidity(target);
        // Rewrite the continuation to be Promise chains
        var originalNode = types.isStatement(target.node) ? target.node : types.expressionStatement(target.node);
        var rewrittenTail = statementNode || tail.length ? rewriteAsyncNode(generatorState, target, blockStatement((statementNode ? [statementNode] : []).concat(tail)), additionalConstantNames).body : [];
        checkPathValidity(target);
        // Strip dead code from the continuation
        var blocks = removeUnnecessaryReturnStatements(rewrittenTail.filter(isNonEmptyStatement));
        checkPathValidity(target);
        var replacement;
        if (blocks.length) {
            // Have a continuation, optimize it
            if (exitCheck) {
                if (temporary && !types.isIdentifier(temporary)) {
                    var temporaryIdentifier = temporary = target.scope.generateUidIdentifier("temp");
                    var declaration = types.variableDeclaration("const", [types.variableDeclarator(temporary, temporaryIdentifier)]);
                    blocks = [declaration].concat(blocks);
                    temporary = temporaryIdentifier;
                }
                blocks = removeUnnecessaryReturnStatements([types.ifStatement(exitCheck, returnStatement(temporary))].concat(blocks));
            }
            // Build a function expression for it
            var fn = functionize(generatorState.state, temporary ? [temporary] : [], blockStatement(blocks), target);
            // Emit an await expression for the await expression that calls the continuation
            replacement = awaitAndContinue(generatorState.state, target, awaitExpression, fn, directExpression);
            originalNode = types.blockStatement([originalNode].concat(tail));
        }
        else if (pathsReturnOrThrow(target).any || target.parentPath.isArrowFunctionExpression()) {
            // Emit an await expression for the await expression that passes through the output
            replacement = awaitAndContinue(generatorState.state, target, awaitExpression, undefined, directExpression);
        }
        else {
            // Emit an await expression for the await expression that ignores the output
            replacement = awaitAndContinue(generatorState.state, target, awaitExpression, emptyFunction(generatorState.state, target), directExpression);
        }
        checkPathValidity(target);
        // Insert a call to return the awaited expression
        if (target.isExpression() && target.parentPath.isArrowFunctionExpression()) {
            target.replaceWith(replacement.expression);
        }
        else if (target.isBlockStatement() && target.parentPath.isFunctionExpression()) {
            target.replaceWith(types.blockStatement([returnStatement(replacement.expression, originalNode)]));
        }
        else {
            target.replaceWith(returnStatement(replacement.expression, originalNode));
        }
        // Insert any new variable declarators the await call needed
        if (replacement.declarators.length) {
            target.insertBefore(types.variableDeclaration("const", replacement.declarators));
        }
        // Hoist the call arguments if configured to do so
        if (readConfigKey(generatorState.state.opts, "hoist")) {
            if (target.isExpression()) {
                hoistCallArguments(generatorState.state, target, additionalConstantNames);
            }
            else if (target.isReturnStatement()) {
                var argument = target.get("argument");
                if (argument.node) {
                    hoistCallArguments(generatorState.state, argument, additionalConstantNames);
                }
            }
        }
    }
    // Hoist a common subexpression into a named constant
    function rewriteToNamedConstant(targetPath, callback) {
        var declarators = Object.create(null);
        var result = callback(function (name, path) {
            if (!Object.hasOwnProperty.call(declarators, name)) {
                declarators[name] = {
                    kind: "const",
                    id: path.scope.generateUidIdentifier(name),
                    init: path.node
                };
            }
            path.replaceWith(declarators[name].id);
        });
        for (var _i = 0, _a = Object.keys(declarators); _i < _a.length; _i++) {
            var key = _a[_i];
            targetPath.scope.push(declarators[key]);
        }
        return result;
    }
    // Rewrite this expression visitor
    var rewriteThisVisitor = {
        Function: function (path) {
            if (!path.isArrowFunctionExpression()) {
                path.skip();
            }
        },
        ThisExpression: function (path) {
            this.rewrite("this", path);
        }
    };
    // Rewrite this into _this so that it can be used in continuations
    function rewriteThisExpressions(rewritePath, targetPath) {
        rewriteToNamedConstant(targetPath, function (rewrite) { return rewritePath.traverse(rewriteThisVisitor, { rewrite: rewrite }); });
    }
    // Extracts all the identifiers populated in an LVal
    function identifiersInLVal(id, result) {
        if (result === void 0) { result = []; }
        switch (id.type) {
            case "Identifier":
                result.push(id);
                break;
            case "AssignmentPattern":
                identifiersInLVal(id.left);
                break;
            case "ArrayPattern":
                for (var _i = 0, _a = id.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (types.isLVal(element)) {
                        identifiersInLVal(element, result);
                    }
                }
                break;
            case "RestElement":
                identifiersInLVal(id.argument, result);
                break;
            case "ObjectPattern":
                for (var _b = 0, _c = id.properties; _b < _c.length; _b++) {
                    var property = _c[_b];
                    if (types.isRestProperty(property)) {
                        identifiersInLVal(property.argument, result);
                    }
                    else {
                        identifiersInLVal(property.value, result);
                    }
                }
                break;
            default:
                throw new Error("Unexpected node is not an LVal: " + id);
        }
        return result;
    }
    // Checks if any identifiers are referenced before a specific path
    function anyIdentifiersRequireHoisting(identifiers, path) {
        for (var _i = 0, identifiers_1 = identifiers; _i < identifiers_1.length; _i++) {
            var id = identifiers_1[_i];
            var binding = path.scope.getBinding(id.name);
            if (!binding || (binding.referencePaths.some(function (referencePath) { return referencePath.willIMaybeExecuteBefore(path); }) || (binding.referencePaths.length && path.getDeepestCommonAncestorFrom(binding.referencePaths.concat([path])) !== path.parentPath))) {
                return true;
            }
        }
        return false;
    }
    // Rewrite this, arguments and super visitor
    var rewriteThisArgumentsAndHoistVisitor = {
        Function: function (path) {
            path.skip();
            if (path.isArrowFunctionExpression()) {
                path.traverse(rewriteThisVisitor, this);
            }
        },
        Super: function (path) {
            if (this.rewriteSuper) {
                var parent = path.parentPath;
                if (parent.isMemberExpression() && parent.get("object") === path) {
                    var property = parent.get("property");
                    if (parent.node.computed) {
                        if (!property.isStringLiteral()) {
                            throw path.buildCodeFrameError("Expected a staticly resolvable super expression, got a computed expression of type " + property.node.type, TypeError);
                        }
                    }
                    var grandparent = parent.parentPath;
                    if (property.isIdentifier() && grandparent.isCallExpression() && grandparent.get("callee") === parent) {
                        this.rewrite("super$" + property.node.name, parent);
                        grandparent.replaceWith(types.callExpression(types.memberExpression(parent.node, types.identifier("call")), [types.thisExpression()].concat(grandparent.node.arguments)));
                    }
                }
            }
        },
        ThisExpression: function (path) {
            // Rewrite this
            this.rewrite("this", path);
        },
        Identifier: function (path) {
            // Rewrite arguments
            if (path.node.name === "arguments") {
                this.rewrite("arguments", path);
            }
        },
        VariableDeclaration: function (path) {
            if (path.node.kind === "var") {
                var scope = path.scope;
                var declarations = path.get("declarations");
                if ((path.parentPath.isForInStatement() || path.parentPath.isForOfStatement()) && path.parentPath.get("left") === path && declarations.length === 1) {
                    var lval = declarations[0].node.id;
                    var identifiers = identifiersInLVal(lval);
                    if (anyIdentifiersRequireHoisting(identifiers, path)) {
                        for (var _i = 0, identifiers_2 = identifiers; _i < identifiers_2.length; _i++) {
                            var id = identifiers_2[_i];
                            this.targetPath.scope.push({ id: id });
                        }
                        path.replaceWith(lval);
                    }
                }
                else {
                    var mapped = declarations.map(function (declaration) { return ({ declaration: declaration, identifiers: identifiersInLVal(declaration.node.id) }); });
                    if (mapped.some(function (_a) {
                        var identifiers = _a.identifiers;
                        return anyIdentifiersRequireHoisting(identifiers, path);
                    })) {
                        var expressions = [];
                        for (var _a = 0, mapped_1 = mapped; _a < mapped_1.length; _a++) {
                            var _b = mapped_1[_a], declaration = _b.declaration, identifiers = _b.identifiers;
                            for (var _c = 0, identifiers_3 = identifiers; _c < identifiers_3.length; _c++) {
                                var id = identifiers_3[_c];
                                this.targetPath.scope.push({ id: id });
                            }
                            if (declaration.node.init) {
                                expressions.push(types.assignmentExpression("=", declaration.node.id, declaration.node.init));
                            }
                        }
                        if (expressions.length === 0) {
                            path.remove();
                        }
                        else if (path.parentPath.isForStatement() && path.parentPath.get("init") === path) {
                            path.replaceWith(types.sequenceExpression(expressions));
                        }
                        else {
                            path.replaceWithMultiple(expressions.map(function (expression) { return types.expressionStatement(expression); }));
                        }
                    }
                }
            }
        },
        FunctionDeclaration: function (path) {
            var targetPath = path;
            while (targetPath.parentPath.isBlockStatement()) {
                targetPath = targetPath.parentPath;
            }
            for (var _i = 0, _a = path.getAllPrevSiblings(); _i < _a.length; _i++) {
                var sibling = _a[_i];
                if (!sibling.isFunctionDeclaration()) {
                    var node = path.node;
                    var parentPath = path.parentPath;
                    path.remove();
                    var paths = sibling.insertBefore(node);
                    parentPath.scope.registerDeclaration(paths[0]);
                    return;
                }
            }
        }
    };
    // Rewrite this, arguments and super expressions so that they can be used in continuations
    function rewriteThisArgumentsAndHoistFunctions(rewritePath, targetPath, rewriteSuper) {
        rewriteToNamedConstant(targetPath, function (rewrite) { return rewritePath.traverse(rewriteThisArgumentsAndHoistVisitor, { targetPath: targetPath, rewrite: rewrite, rewriteSuper: rewriteSuper }); });
    }
    // Convert an expression or statement into a callable function expression
    function functionize(state, params, expression, target) {
        if (readConfigKey(state.opts, "target") === "es6") {
            var newExpression = expression;
            if (types.isBlockStatement(newExpression) && newExpression.body.length === 1) {
                newExpression = newExpression.body[0];
            }
            if (types.isReturnStatement(newExpression) && newExpression.argument !== null) {
                newExpression = newExpression.argument;
            }
            var result = types.arrowFunctionExpression(params, types.isStatement(newExpression) && !types.isBlockStatement(newExpression) ? types.blockStatement([newExpression]) : newExpression);
            var usesThisOrArguments_1 = false;
            pathForNewNode(result, target).traverse({
                Function: function (path) {
                    path.skip();
                },
                ThisExpression: function (path) {
                    usesThisOrArguments_1 = true;
                    path.stop();
                },
                Identifier: function (path) {
                    if (path.node.name === "arguments" && identifierSearchesScope(path)) {
                        usesThisOrArguments_1 = true;
                        path.stop();
                    }
                }
            });
            if (!usesThisOrArguments_1) {
                return result;
            }
        }
        if (types.isExpression(expression)) {
            expression = returnStatement(expression);
        }
        if (!types.isBlockStatement(expression)) {
            expression = blockStatement([expression]);
        }
        expression.body = removeUnnecessaryReturnStatements(expression.body);
        return types.functionExpression(undefined, params, expression);
    }
    // Create a block statement from a list of statements
    function blockStatement(statementOrStatements) {
        if ("length" in statementOrStatements) {
            return types.blockStatement(statementOrStatements.filter(function (statement) { return !types.isEmptyStatement(statement); }));
        }
        else if (!types.isBlockStatement(statementOrStatements)) {
            return types.blockStatement([statementOrStatements]);
        }
        else {
            return statementOrStatements;
        }
    }
    // Unwrap function() { return ...(); } expressions 
    function unwrapReturnCallWithEmptyArguments(node, scope, additionalConstantNames) {
        if (isContinuation(node)) {
            var expression = expressionInSingleReturnStatement(node);
            if (expression && types.isCallExpression(expression)) {
                var callTarget = void 0;
                switch (expression.arguments.length) {
                    case 0:
                        // Match function() { return ...(); }
                        callTarget = expression.callee;
                        break;
                    case 1: {
                        var callee = expression.callee;
                        var onlyArgument = expression.arguments[0];
                        // Match function() { return _call(...); }
                        if (types.isIdentifier(callee) && callee._helperName === "_call") {
                            callTarget = onlyArgument;
                        }
                        // Match function() { return _await(...()); } or function() { return Promise.resolve(...()); }
                        if ((types.isIdentifier(callee) || types.isMemberExpression(callee)) && callee._helperName === "_await") {
                            if (types.isCallExpression(onlyArgument) && onlyArgument.arguments.length === 0) {
                                callTarget = onlyArgument.callee;
                            }
                        }
                        break;
                    }
                }
                if (callTarget && types.isExpression(callTarget)) {
                    if (types.isIdentifier(callTarget)) {
                        var binding = scope.getBinding(callTarget.name);
                        if (binding && binding.constant) {
                            return callTarget;
                        }
                        if (additionalConstantNames.indexOf(callTarget.name) !== -1) {
                            return callTarget;
                        }
                    }
                    else if (isContinuation(callTarget)) {
                        return callTarget;
                    }
                }
            }
        }
        return node;
    }
    // Unwrap function(arg) { return something(arg); } expressions
    function unwrapReturnCallWithPassthroughArgument(node, scope) {
        if (isContinuation(node) && node.params.length >= 1) {
            var expression = expressionInSingleReturnStatement(node);
            if (expression && types.isCallExpression(expression) && expression.arguments.length === 1) {
                var firstArgument = expression.arguments[0];
                var firstParam = node.params[0];
                if (types.isIdentifier(firstArgument) && types.isIdentifier(firstParam) && firstArgument.name === firstParam.name) {
                    if (types.isIdentifier(expression.callee)) {
                        var binding = scope.getBinding(expression.callee.name);
                        if (binding && binding.constant) {
                            return expression.callee;
                        }
                        // Simplify calls to known static functions like encodeURIComponent
                        if (Object.hasOwnProperty.call(constantStaticMethods, expression.callee.name)) {
                            return expression.callee;
                        }
                    }
                    else if (types.isMemberExpression(expression.callee)) {
                        // Simplify calls to known static methods like JSON.parse
                        var propertyName = propertyNameOfMemberExpression(expression.callee);
                        if (propertyName !== undefined) {
                            var object = expression.callee.object;
                            if (types.isIdentifier(object) && Object.hasOwnProperty.call(constantStaticMethods, object.name) && !scope.getBinding(object.name)) {
                                var staticMethods = constantStaticMethods[object.name];
                                if (Object.hasOwnProperty.call(staticMethods, propertyName) && staticMethods[propertyName]) {
                                    return expression.callee;
                                }
                            }
                        }
                    }
                }
            }
        }
        return node;
    }
    // Return true if an expression contains entirely literals, with a list of identifiers assumed to have literal values
    function isExpressionOfLiterals(path, literalNames) {
        if (path.isIdentifier()) {
            var name = path.node.name;
            if (name === "undefined" && !path.scope.getBinding("undefined")) {
                return true;
            }
            var binding = path.parentPath.scope.getBinding(name);
            if (binding) {
                return binding.constant;
            }
            if (literalNames.indexOf(name) !== -1) {
                return true;
            }
            if (Object.hasOwnProperty.call(constantStaticMethods, name) && !path.scope.getBinding(name)) {
                return true;
            }
            return false;
        }
        if (path.isMemberExpression()) {
            var object = path.get("object");
            if (object.isIdentifier()) {
                var propertyName = propertyNameOfMemberExpression(path.node);
                if (propertyName !== undefined && Object.hasOwnProperty.call(constantStaticMethods, object.node.name) && !path.scope.getBinding(object.node.name)) {
                    var staticMethods = constantStaticMethods[object.node.name];
                    if (Object.hasOwnProperty.call(staticMethods, propertyName) && staticMethods[propertyName]) {
                        return true;
                    }
                }
            }
            return false;
        }
        if (path.isBooleanLiteral()) {
            return true;
        }
        if (path.isNumericLiteral()) {
            return true;
        }
        if (path.isStringLiteral()) {
            return true;
        }
        if (path.isArrayExpression()) {
            return path.get("elements").every(function (path) { return path === null || path.node === null ? true : isExpressionOfLiterals(path, literalNames); });
        }
        if (path.isObjectExpression()) {
            return path.get("properties").every(function (path) {
                if (!path.isObjectProperty()) {
                    return true;
                }
                if (isExpressionOfLiterals(path.get("value"), literalNames) && (!path.node.computed || isExpressionOfLiterals(path.get("key"), literalNames))) {
                    return true;
                }
                return false;
            });
        }
        if (path.isUnaryExpression()) {
            return isExpressionOfLiterals(path.get("argument"), literalNames);
        }
        if (path.isLogicalExpression() || path.isBinaryExpression()) {
            return isExpressionOfLiterals(path.get("left"), literalNames) && isExpressionOfLiterals(path.get("right"), literalNames);
        }
        if (path.isConditionalExpression()) {
            return isExpressionOfLiterals(path.get("test"), literalNames) && isExpressionOfLiterals(path.get("consequent"), literalNames) && isExpressionOfLiterals(path.get("alternate"), literalNames);
        }
        if (path.isExpression() && isContinuation(path.node)) {
            return true;
        }
        return false;
    }
    // Generate a new identifier named after the current node at a path
    function generateIdentifierForPath(path) {
        var result = path.scope.generateUidIdentifierBasedOnNode(path.node, "temp");
        if (path.isIdentifier() && path.node.name === result.name) {
            return path.scope.generateUidIdentifier("temp");
        }
        return result;
    }
    // Emit a truthy literal, using 1/0 if minified
    function booleanLiteral(value, minify) {
        return minify ? types.numericLiteral(value ? 1 : 0) : types.booleanLiteral(value);
    }
    // Emit an optimized conditional expression, simplifying if possible
    function conditionalExpression(test, consequent, alternate) {
        var looseValue = extractLooseBooleanValue(test);
        if (typeof looseValue !== "undefined") {
            return looseValue ? consequent : alternate;
        }
        while (types.isUnaryExpression(test) && test.operator === "!") {
            test = test.argument;
            var temp = consequent;
            consequent = alternate;
            alternate = temp;
        }
        if ((isValueLiteral(consequent) && isValueLiteral(alternate) && consequent.value === alternate.value) ||
            (types.isNullLiteral(consequent) && types.isNullLiteral(alternate)) ||
            (types.isIdentifier(consequent) && types.isIdentifier(alternate) && consequent.name === alternate.name)) {
            if (types.isIdentifier(test)) {
                return consequent;
            }
        }
        if (types.isIdentifier(test)) {
            consequent = simplifyWithIdentifier(consequent, test, true);
            alternate = simplifyWithIdentifier(alternate, test, false);
        }
        return types.conditionalExpression(test, consequent, alternate);
    }
    // Extract the boolean value of an expression, reading through unary expressions if necessary
    function extractBooleanValue(node) {
        if (types.isBooleanLiteral(node)) {
            return node.value;
        }
        if (types.isUnaryExpression(node)) {
            if (node.operator === "!") {
                var result = extractLooseBooleanValue(node.argument);
                return typeof result === "undefined" ? undefined : !result;
            }
            else if (node.operator === "void") {
                return typeof extractLooseBooleanValue(node.argument) !== "undefined" ? false : undefined;
            }
        }
    }
    // Extract the thruthy value of an expression, reading through literals and unary expressions if necessary
    function extractLooseBooleanValue(node) {
        if (isValueLiteral(node)) {
            return !!node.value;
        }
        if (types.isNullLiteral(node)) {
            return false;
        }
        if (types.isIdentifier(node)) {
            if (alwaysTruthy.indexOf(node.name) !== -1) {
                return true;
            }
            if (node.name === "undefined") {
                return false;
            }
        }
        return extractBooleanValue(node);
    }
    // Emit a logical or, optimizing based on the truthiness of both sides
    function logicalOr(left, right) {
        if (extractLooseBooleanValue(left) === true) {
            return left;
        }
        else if (extractBooleanValue(left) === false) {
            return right;
        }
        else {
            return types.logicalExpression("||", left, right);
        }
    }
    // Emit a logical or, optimizing based on the loose truthiness of both sides assuming that the consumer of the expression only cares about truthiness
    function logicalOrLoose(left, right, minify) {
        switch (extractLooseBooleanValue(left)) {
            case false:
                return extractLooseBooleanValue(right) === false ? booleanLiteral(false, minify) : right;
            case true:
                return booleanLiteral(true, minify);
            default:
                switch (extractLooseBooleanValue(right)) {
                    case false:
                        return left;
                    case true:
                        return booleanLiteral(true, minify);
                    default:
                        return types.logicalExpression("||", left, right);
                }
        }
    }
    // Emit a logical and, optimizing based on the value of the left expression
    function logicalAnd(left, right, extract) {
        if (extract === void 0) { extract = extractBooleanValue; }
        switch (extract(left)) {
            case true:
                return left;
            case false:
                return right;
            default:
                return types.logicalExpression("&&", left, right);
        }
    }
    // Emit a logical not, optimizing where possible
    function logicalNot(node, minify) {
        var literalValue = extractLooseBooleanValue(node);
        if (typeof literalValue !== "undefined") {
            return booleanLiteral(!literalValue, minify);
        }
        if (types.isUnaryExpression(node) && node.operator === "!" && types.isUnaryExpression(node.argument) && node.argument.operator === "!") {
            return node.argument;
        }
        return types.unaryExpression("!", node);
    }
    // Unwrap the expression behind a spread element
    function unwrapSpreadElement(path) {
        if (path.isExpression()) {
            return path;
        }
        if (path.isSpreadElement()) {
            return path.get("argument");
        }
        /* istanbul ignore next */
        throw path.buildCodeFrameError("Expected either an expression or a spread element, got a " + path.type + "!", TypeError);
    }
    // Find the path of a declaration statement to reuse
    function findDeclarationToReuse(path) {
        for (;;) {
            var parent = path.parentPath;
            if (parent.isVariableDeclarator()) {
                var id = parent.get("id");
                if (id.isIdentifier() || id.isPattern()) {
                    return parent;
                }
            }
            var other = void 0;
            if (parent.isConditionalExpression()) {
                var test = parent.get("test");
                if (path === test) {
                    break;
                }
                var consequent = parent.get("consequent");
                var alternate = parent.get("alternate");
                other = consequent === path ? alternate : consequent;
            }
            else if (parent.isLogicalExpression()) {
                var left = parent.get("left");
                var right = parent.get("right");
                other = left === path ? right : left;
            }
            else {
                break;
            }
            var otherAwaitPath = findAwaitOrYieldPath(other);
            if ((otherAwaitPath === other) || !otherAwaitPath) {
                path = path.parentPath;
            }
            else {
                break;
            }
        }
    }
    // Extract prefixes of an await expression out into declarations so that they can be reused in the continuation
    function extractDeclarations(state, originalAwaitPath, awaitExpression, additionalConstantNames) {
        var awaitPath = originalAwaitPath;
        var reusingExisting = findDeclarationToReuse(awaitPath);
        var reusingExistingId = reusingExisting ? reusingExisting.get("id") : undefined;
        var existingIdentifier = reusingExistingId && (reusingExistingId.isIdentifier() || reusingExistingId.isPattern()) ? reusingExistingId.node : undefined;
        var resultIdentifier;
        if (awaitPath.parentPath.isSequenceExpression() && (awaitPath.key < awaitPath.container.length - 1)) {
            originalAwaitPath.replaceWith(types.numericLiteral(0));
        }
        else {
            var newIdentifier = resultIdentifier = existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"));
            originalAwaitPath.replaceWith(types.isIdentifier(newIdentifier) ? newIdentifier : types.numericLiteral(0));
        }
        var declarations = [];
        var isYield = originalAwaitPath.isYieldExpression();
        var directExpression = booleanLiteral(false, readConfigKey(state.opts, "minify"));
        var _loop_1 = function () {
            var parent = awaitPath.parentPath;
            if (parent.isVariableDeclarator()) {
                var beforeDeclarations = [];
                var skipLiterals = true;
                for (var key = parent.key - 1; key >= 0; --key) {
                    var sibling = parent.getSibling(key);
                    if (sibling.isVariableDeclarator()) {
                        var init = sibling.get("init");
                        if (!skipLiterals || (init && !isExpressionOfLiterals(init, additionalConstantNames))) {
                            skipLiterals = false;
                            beforeDeclarations.unshift(sibling.node);
                            sibling.remove();
                        }
                    }
                    else {
                        /* istanbul ignore next */
                        throw sibling.buildCodeFrameError("Expected a variable declarator, got a " + sibling.type + "!", TypeError);
                    }
                }
                if (beforeDeclarations.length) {
                    declarations = declarations.concat(beforeDeclarations.concat(declarations));
                }
            }
            else if (parent.isLogicalExpression()) {
                var left = parent.get("left");
                if (awaitPath !== left) {
                    if (!isYield && !isExpressionOfLiterals(left, additionalConstantNames)) {
                        var leftIdentifier_1 = generateIdentifierForPath(left);
                        declarations = declarations.map(function (declaration) { return declaration.init ? types.variableDeclarator(declaration.id, logicalAnd(parent.node.operator === "||" ? logicalNot(leftIdentifier_1) : leftIdentifier_1, declaration.init)) : declaration; });
                        declarations.unshift(types.variableDeclarator(leftIdentifier_1, left.node));
                        left.replaceWith(leftIdentifier_1);
                    }
                    var isOr = parent.node.operator === "||";
                    awaitExpression = (isOr ? logicalOr : logicalAnd)(left.node, awaitExpression);
                    if (!isYield) {
                        directExpression = logicalOrLoose(isOr ? left.node : logicalNot(left.node), directExpression, readConfigKey(state.opts, "minify"));
                    }
                    if (awaitPath === originalAwaitPath) {
                        if (!resultIdentifier) {
                            resultIdentifier = existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"));
                        }
                        parent.replaceWith(resultIdentifier);
                        awaitPath = parent;
                        return "continue";
                    }
                }
            }
            else if (parent.isBinaryExpression()) {
                var left = parent.get("left");
                if (awaitPath !== left) {
                    if (!isExpressionOfLiterals(left, additionalConstantNames)) {
                        var leftIdentifier = generateIdentifierForPath(left);
                        declarations.unshift(types.variableDeclarator(leftIdentifier, left.node));
                        left.replaceWith(leftIdentifier);
                    }
                }
            }
            else if (parent.isSequenceExpression()) {
                var children = parent.get("expressions");
                var position = children.indexOf(awaitPath);
                for (var i = 0; i < position; i++) {
                    var expression = children[i];
                    if (!isExpressionOfLiterals(expression, additionalConstantNames)) {
                        var sequenceIdentifier = generateIdentifierForPath(expression);
                        declarations.unshift(types.variableDeclarator(sequenceIdentifier, expression.node));
                    }
                    expression.remove();
                }
                if (position === children.length - 1) {
                    parent.replaceWith(children[position]);
                }
            }
            else if (parent.isConditionalExpression()) {
                var test = parent.get("test");
                if (awaitPath !== test) {
                    var testNode_1 = test.node;
                    var consequent_1 = parent.get("consequent");
                    var alternate = parent.get("alternate");
                    var other = consequent_1 === awaitPath ? alternate : consequent_1;
                    var otherAwaitPath = findAwaitOrYieldPath(other);
                    var testIdentifier_1;
                    var isBoth = consequent_1 === awaitPath && otherAwaitPath === alternate;
                    if (!(isBoth && awaitPath === originalAwaitPath) && !isExpressionOfLiterals(test, additionalConstantNames)) {
                        testIdentifier_1 = generateIdentifierForPath(test);
                    }
                    declarations = declarations.map(function (declaration) { return declaration.init ? types.variableDeclarator(declaration.id, (consequent_1 === awaitPath ? logicalAnd : logicalOr)(testIdentifier_1 || testNode_1, declaration.init)) : declaration; });
                    if (testIdentifier_1) {
                        declarations.unshift(types.variableDeclarator(testIdentifier_1, testNode_1));
                        test.replaceWith(testIdentifier_1);
                        testNode_1 = testIdentifier_1;
                    }
                    if (isBoth && otherAwaitPath) {
                        awaitExpression = conditionalExpression(testNode_1, awaitExpression, otherAwaitPath.node.argument);
                        if (!resultIdentifier) {
                            resultIdentifier = existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"));
                        }
                        alternate.replaceWith(resultIdentifier);
                        parent.replaceWith(resultIdentifier);
                    }
                    else {
                        if (!isYield) {
                            directExpression = logicalOrLoose(consequent_1 !== awaitPath ? testNode_1 : logicalNot(testNode_1), directExpression, readConfigKey(state.opts, "minify"));
                        }
                        if (otherAwaitPath) {
                            awaitExpression = consequent_1 !== awaitPath ? conditionalExpression(testNode_1, types.numericLiteral(0), awaitExpression) : conditionalExpression(testNode_1, awaitExpression, types.numericLiteral(0));
                        }
                        else {
                            awaitExpression = consequent_1 !== awaitPath ? conditionalExpression(testNode_1, other.node, awaitExpression) : conditionalExpression(testNode_1, awaitExpression, other.node);
                            if (!resultIdentifier) {
                                resultIdentifier = existingIdentifier || generateIdentifierForPath(originalAwaitPath.get("argument"));
                            }
                            if (awaitPath === originalAwaitPath) {
                                parent.replaceWith(resultIdentifier);
                                awaitPath = parent;
                                return "continue";
                            }
                            other.replaceWith(resultIdentifier);
                        }
                    }
                }
            }
            else if (parent.isCallExpression()) {
                var callee = parent.get("callee");
                if (callee !== awaitPath) {
                    for (var _i = 0, _a = parent.get("arguments"); _i < _a.length; _i++) {
                        var arg = _a[_i];
                        var spreadArg = unwrapSpreadElement(arg);
                        if (spreadArg === awaitPath || arg === awaitPath) {
                            break;
                        }
                        if (!isExpressionOfLiterals(spreadArg, additionalConstantNames)) {
                            var argIdentifier = generateIdentifierForPath(spreadArg);
                            declarations.unshift(types.variableDeclarator(argIdentifier, spreadArg.node));
                            spreadArg.replaceWith(argIdentifier);
                        }
                    }
                    if (!isExpressionOfLiterals(callee, additionalConstantNames) && typeof promiseCallExpressionType(parent.node) === "undefined") {
                        if (callee.isMemberExpression()) {
                            var object = callee.get("object");
                            var property = callee.get("property");
                            var objectDeclarator = void 0;
                            var staticMethods = {};
                            var constantObject = false;
                            if (object.isIdentifier() && Object.hasOwnProperty.call(constantStaticMethods, object.node.name) && !callee.scope.getBinding(object.node.name)) {
                                constantObject = true;
                                staticMethods = constantStaticMethods[object.node.name];
                            }
                            else if (isExpressionOfLiterals(object, additionalConstantNames)) {
                                constantObject = true;
                            }
                            if (!constantObject) {
                                var objectIdentifier = generateIdentifierForPath(object);
                                objectDeclarator = types.variableDeclarator(objectIdentifier, object.node);
                                object.replaceWith(objectIdentifier);
                            }
                            if (!callee.node.computed && property.isIdentifier() && (property.node.name === "call" || Object.hasOwnProperty.call(staticMethods, property.node.name))) {
                                // parent.replaceWith(types.callExpression(types.memberExpression(object.node, types.identifier("call")), parent.node.arguments));
                            }
                            else {
                                var calleeIdentifier = generateIdentifierForPath(property);
                                var calleeNode = callee.node;
                                var newArguments = [__assign({}, object.node)];
                                parent.replaceWith(types.callExpression(types.memberExpression(calleeIdentifier, types.identifier("call")), newArguments.concat(parent.node.arguments)));
                                declarations.unshift(types.variableDeclarator(calleeIdentifier, calleeNode));
                            }
                            if (typeof objectDeclarator !== "undefined") {
                                declarations.unshift(objectDeclarator);
                            }
                        }
                        else if (!callee.isIdentifier() || !(callee.node._helperName || (awaitPath.scope.getBinding(callee.node.name) || { constant: false }).constant)) {
                            var calleeIdentifier = generateIdentifierForPath(callee);
                            var calleeNode = callee.node;
                            callee.replaceWith(calleeIdentifier);
                            declarations.unshift(types.variableDeclarator(calleeIdentifier, calleeNode));
                        }
                    }
                }
            }
            else if (parent.isArrayExpression()) {
                for (var _b = 0, _c = parent.get("elements"); _b < _c.length; _b++) {
                    var element = _c[_b];
                    var spreadElement = unwrapSpreadElement(element);
                    if (element === awaitPath || spreadElement === awaitPath) {
                        break;
                    }
                    if (!isExpressionOfLiterals(spreadElement, additionalConstantNames)) {
                        var elementIdentifier = generateIdentifierForPath(spreadElement);
                        declarations.unshift(types.variableDeclarator(elementIdentifier, spreadElement.node));
                        spreadElement.replaceWith(elementIdentifier);
                    }
                }
            }
            else if (parent.isObjectExpression()) {
                for (var _d = 0, _e = parent.get("properties"); _d < _e.length; _d++) {
                    var prop = _e[_d];
                    if (prop === awaitPath) {
                        break;
                    }
                    if (prop.isObjectProperty()) {
                        if (prop.node.computed) {
                            var propKey = prop.get("key");
                            if (propKey === awaitPath) {
                                break;
                            }
                            if (!isExpressionOfLiterals(propKey, additionalConstantNames)) {
                                var keyIdentifier = generateIdentifierForPath(propKey);
                                declarations.unshift(types.variableDeclarator(keyIdentifier, propKey.node));
                                propKey.replaceWith(keyIdentifier);
                            }
                        }
                        var propValue = prop.get("value");
                        if (propValue === awaitPath) {
                            break;
                        }
                        if (!isExpressionOfLiterals(propValue, additionalConstantNames)) {
                            var propIdentifier = generateIdentifierForPath(propValue);
                            declarations.unshift(types.variableDeclarator(propIdentifier, propValue.node));
                            propValue.replaceWith(propIdentifier);
                        }
                    }
                }
            }
            if (parent.isStatement()) {
                return { value: { declarationKind: reusingExisting ? reusingExisting.parent.kind : "const", declarations: declarations, awaitExpression: awaitExpression, directExpression: directExpression, reusingExisting: reusingExisting, resultIdentifier: resultIdentifier } };
            }
            else {
                awaitPath = parent;
            }
        };
        for (;;) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    // Helper to skip a node
    function skipNode(path) {
        path.skip();
    }
    // Visitor to find an await path
    var awaitPathVisitor = {
        Function: skipNode,
        AwaitExpression: function (path) {
            this.result = path;
            path.stop();
        },
        YieldExpression: function (path) {
            this.result = path;
            path.stop();
        }
    };
    // Finds the first child await or yield path, skipping functions
    function findAwaitOrYieldPath(path) {
        if (path.isAwaitExpression() || path.isYieldExpression()) {
            return path;
        }
        var state = Object.create(null);
        path.traverse(awaitPathVisitor, state);
        return state.result;
    }
    // Build an expression that checks if a loop should be exited
    function buildBreakExitCheck(state, exitIdentifier, breakIdentifiers) {
        var expressions = (breakIdentifiers.map(function (identifier) { return identifier.identifier; }) || []).concat(exitIdentifier ? [exitIdentifier] : []);
        if (expressions.length) {
            return expressions.reduce(function (accumulator, identifier) { return logicalOrLoose(accumulator, identifier, readConfigKey(state.opts, "minify")); });
        }
    }
    // Pushes missing values onto an array
    function pushMissing(destination, source) {
        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
            var value = source_1[_i];
            var index = destination.indexOf(value);
            if (index < 0) {
                destination.push(value);
            }
        }
    }
    // Assigns to a break identifier
    function setBreakIdentifier(value, breakIdentifier) {
        return types.assignmentExpression("=", breakIdentifier.identifier, value);
    }
    // Assigns to all break identifiers in a list
    function setBreakIdentifiers(breakIdentifiers, pluginState) {
        return breakIdentifiers.reduce(setBreakIdentifier, booleanLiteral(true, readConfigKey(pluginState.opts, "minify")));
    }
    // Visitor that replaces all returns and breaks with updates to the appropriate break/exit bookkeeping variables
    var replaceReturnsAndBreaksVisitor = {
        Function: skipNode,
        ReturnStatement: function (path) {
            if (!path.node._skip && this.exitIdentifier) {
                var minify = readConfigKey(this.pluginState.opts, "minify");
                if (minify && path.node.argument && extractLooseBooleanValue(path.node.argument) === true) {
                    path.replaceWith(returnStatement(types.assignmentExpression("=", this.exitIdentifier, path.node.argument), path.node));
                }
                else {
                    path.replaceWithMultiple([
                        types.expressionStatement(types.assignmentExpression("=", this.exitIdentifier, booleanLiteral(true, minify))),
                        returnStatement(path.node.argument, path.node),
                    ]);
                }
            }
        },
        BreakStatement: function (path) {
            var replace = returnStatement(undefined, path.node);
            var label = path.node.label;
            var index = label ? this.breakIdentifiers.findIndex(function (breakIdentifier) { return breakIdentifier.name === label.name; }) : 0;
            if (index !== -1 && this.breakIdentifiers.length) {
                var used = this.breakIdentifiers.slice(0, index + 1);
                if (used.length) {
                    pushMissing(this.usedIdentifiers, used);
                    path.replaceWithMultiple([
                        types.expressionStatement(setBreakIdentifiers(used, this.pluginState)),
                        replace,
                    ]);
                    return;
                }
            }
            path.replaceWith(replace);
        },
        ContinueStatement: function (path) {
            var replace = returnStatement(undefined, path.node);
            var label = path.node.label;
            var index = label ? this.breakIdentifiers.findIndex(function (breakIdentifier) { return breakIdentifier.name === label.name; }) : 0;
            if (index !== -1 && this.breakIdentifiers.length) {
                var used = this.breakIdentifiers.slice(0, index);
                if (used.length) {
                    pushMissing(this.usedIdentifiers, used);
                    path.replaceWithMultiple([
                        types.expressionStatement(setBreakIdentifiers(used, this.pluginState)),
                        replace,
                    ]);
                    return;
                }
            }
            path.replaceWith(replace);
        }
    };
    // Helper that replaces all returns and breaks with updates to the appropriate break/exit bookkeeping variables
    function replaceReturnsAndBreaks(pluginState, path, exitIdentifier) {
        var state = { pluginState: pluginState, exitIdentifier: exitIdentifier, breakIdentifiers: breakContinueStackForPath(path), usedIdentifiers: [] };
        path.traverse(replaceReturnsAndBreaksVisitor, state);
        for (var _i = 0, _a = state.usedIdentifiers; _i < _a.length; _i++) {
            var identifier = _a[_i];
            if (!identifier.path.parentPath.scope.getBinding(identifier.identifier.name)) {
                identifier.path.parentPath.scope.push({ kind: "let", id: identifier.identifier, init: readConfigKey(pluginState.opts, "minify") ? undefined : booleanLiteral(false, readConfigKey(pluginState.opts, "minify")) });
            }
        }
        return state.usedIdentifiers;
    }
    // Finds the break identifier associated with a path
    function breakIdentifierForPath(path) {
        var result = path.node._breakIdentifier;
        if (!result) {
            result = path.node._breakIdentifier = path.scope.generateUidIdentifier(path.parentPath.isLabeledStatement() ? path.parentPath.node.label.name + "Interrupt" : "interrupt");
        }
        return result;
    }
    // Visitor that searches for unlabeled break statements
    var simpleBreakOrContinueReferencesVisitor = {
        Function: skipNode,
        Loop: skipNode,
        SwitchStatement: skipNode,
        BreakStatement: function (path) {
            if (!path.node.label) {
                this.references.push(path);
            }
        },
        // ContinueStatement(path) {
        // 	if (!path.node.label) {
        // 		this.references.push(path);
        // 	}
        // },
        ReturnStatement: function (path) {
            var originalNode = path.node._originalNode;
            if (originalNode) {
                traverse(wrapNodeInStatement(originalNode), simpleBreakOrContinueReferencesVisitor, path.scope, this, path);
                path.skip();
            }
        }
    };
    // Searches for unlabeled break statements
    function simpleBreakOrContinueReferences(path) {
        var state = { references: [] };
        path.traverse(simpleBreakOrContinueReferencesVisitor, state);
        return state.references;
    }
    // Visitor that searches for named label breaks/continues
    var namedLabelReferencesVisitor = {
        Function: skipNode,
        BreakStatement: function (path) {
            if (path.node.label && path.node.label.name === this.name) {
                this.breaks.push(path);
            }
        },
        ContinueStatement: function (path) {
            if (path.node.label && path.node.label.name === this.name) {
                this.continues.push(path);
            }
        },
        ReturnStatement: function (path) {
            var originalNode = path.node._originalNode;
            if (originalNode) {
                traverse(wrapNodeInStatement(originalNode), namedLabelReferencesVisitor, path.scope, this, path);
                path.skip();
            }
        }
    };
    // Searches for named label breaks/continues
    function namedLabelReferences(labelPath, targetPath) {
        var state = { name: labelPath.node.label.name, breaks: [], continues: [] };
        targetPath.traverse(namedLabelReferencesVisitor, state);
        return state;
    }
    // Build the break/continue stack for a path
    function breakContinueStackForPath(path) {
        var current = path;
        var result = [];
        while (current && !current.isFunction()) {
            if (current.isLoop() || current.isSwitchStatement()) {
                var breaks = pathsBreak(current);
                if (breaks.any && !breaks.all) {
                    var simpleReferences = simpleBreakOrContinueReferences(current);
                    if (current.parentPath.isLabeledStatement()) {
                        var refs = namedLabelReferences(current.parentPath, path);
                        if (simpleReferences.length || refs.breaks.length || refs.continues.length) {
                            result.push({
                                identifier: breakIdentifierForPath(current),
                                name: current.parentPath.node.label.name,
                                path: current.parentPath
                            });
                        }
                        current = current.parentPath;
                    }
                    else if (simpleReferences.length) {
                        result.push({
                            identifier: breakIdentifierForPath(current),
                            path: current
                        });
                    }
                }
            }
            else if (current.isLabeledStatement()) {
                var refs = namedLabelReferences(current, path);
                if (refs.breaks.length || refs.continues.length) {
                    result.push({
                        identifier: breakIdentifierForPath(current.get("body")),
                        name: current.node.label.name,
                        path: current
                    });
                }
            }
            current = current.parentPath;
        }
        return result;
    }
    // Check if a path is a for-await statement (not supported on all Babel versions)
    function isForAwaitStatement(path) {
        return path.isForAwaitStatement ? path.isForAwaitStatement() : false;
    }
    // Find the most immediate statement parent of a path
    function getStatementOrArrowBodyParent(path) {
        var parent = path;
        do {
            if (parent.isStatement()) {
                return parent;
            }
            if (parent.isArrowFunctionExpression()) {
                return parent.get("body");
            }
        } while (parent = parent.parentPath);
        /* istanbul ignore next */
        throw path.buildCodeFrameError("Expected a statement parent!", TypeError);
    }
    // Add constant names to a contant name array
    function addConstantNames(additionalConstantNames, node) {
        if (types.isIdentifier(node)) {
            if (additionalConstantNames.indexOf(node.name) === -1) {
                additionalConstantNames.push(node.name);
            }
        }
        else if (types.isArrayPattern(node)) {
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (types.isIdentifier(element) || types.isPattern(element) || types.isRestElement(element)) {
                    addConstantNames(additionalConstantNames, element);
                }
            }
        }
        else if (types.isObjectPattern(node)) {
            for (var _b = 0, _c = node.properties; _b < _c.length; _b++) {
                var property = _c[_b];
                if (types.isObjectProperty(property)) {
                    addConstantNames(additionalConstantNames, property.key);
                }
                else if (types.isRestProperty(property)) {
                    addConstantNames(additionalConstantNames, property.argument);
                }
            }
        }
        else if (types.isRestElement(node)) {
            addConstantNames(additionalConstantNames, node.argument);
        }
    }
    // Calls the _yield helper on an expression
    function yieldOnExpression(state, expression) {
        var generatorIdentifier = state.generatorIdentifier;
        if (typeof generatorIdentifier === "undefined") {
            /* istanbul ignore next */
            throw new Error("Encountered a yield expression outside a generator function!");
        }
        var callee = types.memberExpression(generatorIdentifier, types.identifier("_yield"));
        callee._helperName = "_yield";
        return types.callExpression(callee, [expression]);
    }
    // Rewrites an await or for-await expression
    function rewriteAwaitOrYieldPath(rewritePath) {
        var state = this;
        var pluginState = state.generatorState.state;
        var path = state.path;
        var additionalConstantNames = state.additionalConstantNames;
        var awaitPath;
        var processExpressions;
        var rewritePathCopy = rewritePath;
        if (rewritePath.isAwaitExpression() || rewritePath.isYieldExpression()) {
            awaitPath = rewritePath;
            processExpressions = true;
        }
        else if (rewritePath.isForOfStatement() || isForAwaitStatement(rewritePath)) {
            var left = rewritePath.get("left");
            if (left.isAwaitExpression()) {
                awaitPath = left.get("argument");
            }
            else if (left.isSpreadElement()) {
                awaitPath = unwrapSpreadElement(left);
            }
            else {
                awaitPath = left;
            }
            processExpressions = false;
        }
        else {
            /* istanbul ignore next */
            throw rewritePathCopy.buildCodeFrameError("Expected either an await expression or a for await statement, got a " + rewritePathCopy.type + "!", TypeError);
        }
        var paths = [];
        {
            // Determine if we need an exit identifier and rewrite break/return statements
            var targetPath = awaitPath;
            var shouldPushExitIdentifier = false;
            while (targetPath !== path) {
                var parent = targetPath.parentPath;
                if (!parent.isSwitchCase() && !parent.isBlockStatement()) {
                    var exitIdentifier = void 0;
                    var explicitExits = pathsReturnOrThrow(parent);
                    if (!explicitExits.all && explicitExits.any && (parent.isLoop() || exitsInTail(parent))) {
                        if (!state.exitIdentifier) {
                            state.exitIdentifier = targetPath.scope.generateUidIdentifier("exit");
                            shouldPushExitIdentifier = true;
                        }
                        exitIdentifier = state.exitIdentifier;
                    }
                    paths.push({
                        targetPath: targetPath,
                        explicitExits: explicitExits,
                        parent: parent,
                        exitIdentifier: exitIdentifier
                    });
                }
                targetPath = parent;
            }
            if (shouldPushExitIdentifier) {
                path.scope.push({ kind: "let", id: state.exitIdentifier, init: readConfigKey(pluginState.opts, "minify") ? undefined : booleanLiteral(false, readConfigKey(pluginState.opts, "minify")) });
            }
        }
        var _loop_2 = function (item) {
            var parent = item.parent;
            if (parent.isForStatement() || parent.isWhileStatement() || parent.isDoWhileStatement() || parent.isForInStatement() || parent.isForOfStatement() || isForAwaitStatement(parent) || parent.isLabeledStatement()) {
                item.breakIdentifiers = replaceReturnsAndBreaks(pluginState, parent.get("body"), item.exitIdentifier);
                if (parent.isForStatement()) {
                    if (item.forToIdentifiers = identifiersInForToLengthStatement(parent)) {
                        addConstantNames(additionalConstantNames, item.forToIdentifiers.i);
                    }
                }
            }
            else if (item.parent.isSwitchStatement()) {
                item.cases = item.parent.get("cases").map(function (casePath) {
                    return {
                        casePath: casePath,
                        caseExits: pathsReturnOrThrow(casePath),
                        caseBreaks: pathsBreak(casePath),
                        breakIdentifiers: replaceReturnsAndBreaks(pluginState, casePath, item.exitIdentifier),
                        test: casePath.node.test
                    };
                });
            }
            else if (item.exitIdentifier) {
                replaceReturnsAndBreaks(pluginState, parent, item.exitIdentifier);
            }
        };
        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
            var item = paths_1[_i];
            _loop_2(item);
        }
        var _loop_3 = function (targetPath, explicitExits, breakIdentifiers, parent, exitIdentifier, cases, forToIdentifiers) {
            if (parent.isExpressionStatement() && (targetPath.isAwaitExpression() || targetPath.isYieldExpression()) && processExpressions) {
                processExpressions = false;
                relocateTail(state.generatorState, targetPath.isYieldExpression() ? yieldOnExpression(state.generatorState, targetPath.node.argument) : targetPath.node.argument, undefined, parent, additionalConstantNames, undefined, undefined, targetPath.isYieldExpression() ? undefined : booleanLiteral(false, readConfigKey(pluginState.opts, "minify")));
            }
            else if (parent.isIfStatement()) {
                var test = parent.get("test");
                if (targetPath !== test) {
                    var resultIdentifier = void 0;
                    if (!explicitExits.all && explicitExits.any) {
                        resultIdentifier = path.scope.generateUidIdentifier("result");
                        addConstantNames(additionalConstantNames, resultIdentifier);
                    }
                    if (!explicitExits.all) {
                        var consequent = parent.get("consequent");
                        rewriteAsyncBlock(state.generatorState, consequent, additionalConstantNames, exitIdentifier);
                        var alternate = parent.get("alternate");
                        if (alternate.isStatement()) {
                            rewriteAsyncBlock(state.generatorState, alternate, additionalConstantNames, exitIdentifier);
                        }
                        var fn = functionize(pluginState, [], blockStatement([parent.node]), targetPath);
                        relocateTail(state.generatorState, types.callExpression(fn, []), undefined, parent, additionalConstantNames, resultIdentifier, exitIdentifier);
                        processExpressions = false;
                    }
                }
            }
            else if (parent.isTryStatement()) {
                var temporary = explicitExits.any && !explicitExits.all ? path.scope.generateUidIdentifier("result") : undefined;
                var exitCheck = buildBreakExitCheck(pluginState, explicitExits.any && !explicitExits.all ? exitIdentifier : undefined, []);
                var expression = rewriteAsyncNode(state.generatorState, parent, parent.node.block, additionalConstantNames, exitIdentifier);
                var catchClause = parent.node.handler;
                if (catchClause) {
                    var param = catchClause.param;
                    var paramIsUsed = param !== null && parent.get("handler").scope.getBinding(param.name).referencePaths.length !== 0;
                    var fn = catchClause.body.body.length ? rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, paramIsUsed ? [param] : [], catchClause.body, targetPath), additionalConstantNames, exitIdentifier) : emptyFunction(pluginState, parent);
                    expression = types.callExpression(helperReference(pluginState, path, state.generatorState.generatorIdentifier ? "_catchInGenerator" : "_catch"), [unwrapReturnCallWithEmptyArguments(functionize(pluginState, [], expression, targetPath), path.scope, additionalConstantNames), fn]);
                }
                if (parent.node.finalizer) {
                    var finallyName = void 0;
                    var finallyArgs = void 0;
                    var finallyBody = parent.node.finalizer.body;
                    if (!pathsReturnOrThrow(parent.get("finalizer")).all) {
                        var resultIdentifier = temporary || path.scope.generateUidIdentifier("result");
                        addConstantNames(additionalConstantNames, resultIdentifier);
                        var wasThrownIdentifier = path.scope.generateUidIdentifier("wasThrown");
                        addConstantNames(additionalConstantNames, wasThrownIdentifier);
                        finallyArgs = [wasThrownIdentifier, resultIdentifier];
                        if (readConfigKey(pluginState.opts, "inlineHelpers")) {
                            finallyBody = finallyBody.concat([
                                types.ifStatement(wasThrownIdentifier, types.throwStatement(resultIdentifier)),
                                types.returnStatement(resultIdentifier),
                            ]);
                        }
                        else {
                            finallyBody = finallyBody.concat(returnStatement(types.callExpression(helperReference(pluginState, parent, "_rethrow"), [wasThrownIdentifier, resultIdentifier])));
                        }
                        finallyName = "_finallyRethrows";
                    }
                    else {
                        finallyArgs = [];
                        finallyName = "_finally";
                    }
                    var fn = functionize(pluginState, finallyArgs, blockStatement(finallyBody), targetPath);
                    var rewritten = rewriteAsyncNode(state.generatorState, parent, fn, additionalConstantNames, exitIdentifier);
                    expression = types.callExpression(helperReference(pluginState, parent, finallyName), [unwrapReturnCallWithEmptyArguments(functionize(pluginState, [], expression, targetPath), path.scope, additionalConstantNames), rewritten]);
                }
                relocateTail(state.generatorState, types.isExpression(expression) ? expression : types.callExpression(functionize(pluginState, [], expression, targetPath), []), undefined, parent, additionalConstantNames, temporary, exitCheck);
                processExpressions = false;
            }
            else if (parent.isForStatement() || parent.isWhileStatement() || parent.isDoWhileStatement() || parent.isForInStatement() || parent.isForOfStatement() || isForAwaitStatement(parent)) {
                var breaks = pathsBreak(parent);
                var label = parent.parentPath.isLabeledStatement() ? parent.parentPath.node.label.name : undefined;
                if (parent.isForInStatement() || parent.isForOfStatement() || isForAwaitStatement(parent)) {
                    var right = parent.get("right");
                    if (awaitPath !== right) {
                        var left = parent.get("left");
                        var loopIdentifier = left.isVariableDeclaration() ? left.get("declarations")[0].get("id") : left;
                        if (loopIdentifier.isIdentifier() || loopIdentifier.isPattern()) {
                            var forOwnBodyPath = parent.isForInStatement() && extractForOwnBodyPath(parent);
                            var bodyBlock = blockStatement((forOwnBodyPath || parent.get("body")).node);
                            var params = [right.node, rewriteAsyncNode(state.generatorState, parent, bodyBlock.body.length ? functionize(pluginState, [loopIdentifier.node], bodyBlock, targetPath) : emptyFunction(pluginState, parent), additionalConstantNames, exitIdentifier)];
                            var exitCheck = buildBreakExitCheck(pluginState, exitIdentifier, breakIdentifiers || []);
                            if (exitCheck) {
                                params.push(functionize(pluginState, [], types.blockStatement([returnStatement(exitCheck)]), targetPath));
                            }
                            var loopCall = types.callExpression(helperReference(pluginState, parent, parent.isForInStatement() ? forOwnBodyPath ? "_forOwn" : "_forIn" : isForAwaitStatement(parent) ? "_forAwaitOf" : "_forOf"), params);
                            var resultIdentifier = undefined;
                            if (explicitExits.any) {
                                resultIdentifier = path.scope.generateUidIdentifier("result");
                                addConstantNames(additionalConstantNames, resultIdentifier);
                            }
                            relocateTail(state.generatorState, loopCall, undefined, label && parent.parentPath.isStatement() ? parent.parentPath : parent, additionalConstantNames, resultIdentifier, exitIdentifier);
                            processExpressions = false;
                        }
                        else {
                            /* istanbul ignore next */
                            throw loopIdentifier.buildCodeFrameError("Expected an identifier or pattern, but got a " + loopIdentifier.type + "!", TypeError);
                        }
                    }
                }
                else {
                    var testExpression = parent.node.test;
                    var breakExitCheck = buildBreakExitCheck(pluginState, exitIdentifier, breakIdentifiers || []);
                    if (breakExitCheck) {
                        var inverted = logicalNot(breakExitCheck, readConfigKey(pluginState.opts, "minify"));
                        testExpression = testExpression && (!types.isBooleanLiteral(testExpression) || !testExpression.value) ? logicalAnd(inverted, testExpression, extractLooseBooleanValue) : inverted;
                    }
                    if (testExpression) {
                        testExpression = rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [], testExpression, targetPath), additionalConstantNames, exitIdentifier, true);
                    }
                    var isDoWhile = parent.isDoWhileStatement();
                    var loopCall = void 0;
                    if (forToIdentifiers && !isDoWhile) {
                        var args = [forToIdentifiers.array, rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [forToIdentifiers.i], blockStatement(parent.node.body), targetPath), additionalConstantNames, exitIdentifier)];
                        if (breakExitCheck) {
                            args.push(functionize(pluginState, [], breakExitCheck, targetPath));
                        }
                        loopCall = types.callExpression(helperReference(pluginState, parent, "_forTo"), args);
                    }
                    else {
                        var updateExpression = null;
                        if (parent.isForStatement()) {
                            updateExpression = parent.node.update;
                            if (updateExpression) {
                                updateExpression = rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [], updateExpression, targetPath), additionalConstantNames, exitIdentifier, true);
                            }
                            var init = parent.get("init");
                            if (init.node) {
                                parent.insertBefore(init.isExpression() ? types.expressionStatement(init.node) : init.node);
                            }
                        }
                        var forIdentifier = path.scope.generateUidIdentifier("for");
                        var bodyFunction = rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [], blockStatement(parent.node.body), targetPath), additionalConstantNames, exitIdentifier);
                        var testFunction = unwrapReturnCallWithEmptyArguments(testExpression || voidExpression(), path.scope, additionalConstantNames);
                        var updateFunction = unwrapReturnCallWithEmptyArguments(updateExpression || voidExpression(), path.scope, additionalConstantNames);
                        loopCall = isDoWhile ? types.callExpression(helperReference(pluginState, parent, "_do"), [bodyFunction, testFunction]) : types.callExpression(helperReference(pluginState, parent, "_for"), [testFunction, updateFunction, bodyFunction]);
                    }
                    var resultIdentifier = undefined;
                    if (explicitExits.any) {
                        resultIdentifier = path.scope.generateUidIdentifier("result");
                        addConstantNames(additionalConstantNames, resultIdentifier);
                    }
                    relocateTail(state.generatorState, loopCall, undefined, parent, additionalConstantNames, resultIdentifier, exitIdentifier);
                    processExpressions = false;
                }
            }
            else if (parent.isSwitchStatement()) {
                var label = parent.parentPath.isLabeledStatement() ? parent.parentPath.node.label.name : undefined;
                var discriminant = parent.get("discriminant");
                var testPaths = parent.get("cases").map(function (casePath) { return casePath.get("test"); });
                if (awaitPath !== discriminant && !(explicitExits.all && !testPaths.some(function (testPath) { return testPath.node ? findAwaitOrYieldPath(testPath) !== undefined : false; }))) {
                    var resultIdentifier = void 0;
                    if (!explicitExits.all && explicitExits.any) {
                        resultIdentifier = path.scope.generateUidIdentifier("result");
                        addConstantNames(additionalConstantNames, resultIdentifier);
                    }
                    var caseNodes = types.arrayExpression(cases ? cases.map(function (caseItem) {
                        var args = [];
                        var consequent;
                        if (caseItem.casePath.node.consequent) {
                            var rewritten = rewriteAsyncNode(state.generatorState, parent, blockStatement(removeUnnecessaryReturnStatements(caseItem.casePath.node.consequent)), additionalConstantNames, exitIdentifier);
                            if (rewritten.body.length) {
                                consequent = functionize(pluginState, [], rewritten, targetPath);
                            }
                        }
                        if (caseItem.casePath.node.test) {
                            args.push(rewriteAsyncNode(state.generatorState, parent, functionize(pluginState, [], caseItem.casePath.node.test, targetPath), additionalConstantNames));
                        }
                        else if (consequent) {
                            args.push(voidExpression());
                        }
                        if (consequent) {
                            var useBreakIdentifier = !caseItem.caseBreaks.all && caseItem.caseBreaks.any;
                            args.push(consequent);
                            if (!caseItem.caseExits.any && !caseItem.caseBreaks.any) {
                                args.push(emptyFunction(pluginState, parent));
                            }
                            else if (!(caseItem.caseExits.all || caseItem.caseBreaks.all)) {
                                var breakCheck = buildBreakExitCheck(pluginState, caseItem.caseExits.any ? exitIdentifier : undefined, caseItem.breakIdentifiers);
                                if (breakCheck) {
                                    args.push(functionize(pluginState, [], types.blockStatement([returnStatement(breakCheck)]), targetPath));
                                }
                            }
                        }
                        return types.arrayExpression(args);
                    }) : []);
                    var switchCall = types.callExpression(helperReference(pluginState, parent, "_switch"), [discriminant.node, caseNodes]);
                    relocateTail(state.generatorState, switchCall, undefined, label && parent.parentPath.isStatement() ? parent.parentPath : parent, additionalConstantNames, resultIdentifier, exitIdentifier);
                    processExpressions = false;
                }
            }
            else if (parent.isLabeledStatement()) {
                var resultIdentifier = void 0;
                if (!explicitExits.all && explicitExits.any) {
                    resultIdentifier = path.scope.generateUidIdentifier("result");
                    addConstantNames(additionalConstantNames, resultIdentifier);
                }
                if (resultIdentifier || (breakIdentifiers && breakIdentifiers.length)) {
                    var filteredBreakIdentifiers = breakIdentifiers ? breakIdentifiers.filter(function (id) { return id.name !== parent.node.label.name; }) : [];
                    var fn = functionize(pluginState, [], blockStatement(parent.node.body), targetPath);
                    var rewritten = rewriteAsyncNode(state.generatorState, parent, fn, additionalConstantNames, exitIdentifier);
                    var exitCheck = buildBreakExitCheck(pluginState, explicitExits.any ? exitIdentifier : undefined, filteredBreakIdentifiers);
                    relocateTail(state.generatorState, types.callExpression(rewritten, []), undefined, parent, additionalConstantNames, resultIdentifier, exitCheck);
                    processExpressions = false;
                }
            }
        };
        for (var _a = 0, paths_2 = paths; _a < paths_2.length; _a++) {
            var _b = paths_2[_a], targetPath = _b.targetPath, explicitExits = _b.explicitExits, breakIdentifiers = _b.breakIdentifiers, parent = _b.parent, exitIdentifier = _b.exitIdentifier, cases = _b.cases, forToIdentifiers = _b.forToIdentifiers;
            _loop_3(targetPath, explicitExits, breakIdentifiers, parent, exitIdentifier, cases, forToIdentifiers);
        }
        if (processExpressions) {
            if (awaitPath.isAwaitExpression() || awaitPath.isYieldExpression()) {
                var originalArgument = awaitPath.node.argument;
                var parent = getStatementOrArrowBodyParent(awaitPath);
                var _c = extractDeclarations(pluginState, awaitPath, originalArgument, additionalConstantNames), declarationKind = _c.declarationKind, declarations = _c.declarations, awaitExpression = _c.awaitExpression, directExpression = _c.directExpression, reusingExisting = _c.reusingExisting, resultIdentifier = _c.resultIdentifier;
                if (resultIdentifier) {
                    addConstantNames(additionalConstantNames, resultIdentifier);
                }
                if (declarations.length) {
                    for (var _d = 0, declarations_1 = declarations; _d < declarations_1.length; _d++) {
                        var id = declarations_1[_d].id;
                        addConstantNames(additionalConstantNames, id);
                    }
                    if (parent.parentPath.isBlockStatement()) {
                        parent.insertBefore(types.variableDeclaration(declarationKind, declarations));
                    }
                    else {
                        parent.replaceWith(blockStatement([
                            types.variableDeclaration(declarationKind, declarations),
                            types.isStatement(parent.node) ? parent.node : returnStatement(parent.node)
                        ]));
                        parent = parent.get("body")[1];
                    }
                }
                if (reusingExisting) {
                    if (types.isVariableDeclaration(reusingExisting.parent) && reusingExisting.parent.declarations.length === 1) {
                        reusingExisting.parentPath.replaceWith(types.emptyStatement());
                    }
                    else {
                        reusingExisting.remove();
                    }
                }
                relocateTail(state.generatorState, awaitPath.isYieldExpression() ? yieldOnExpression(state.generatorState, awaitExpression) : awaitExpression, parent.isStatement() ? parent.node : undefined, parent, additionalConstantNames, resultIdentifier, undefined, awaitPath.isYieldExpression() ? undefined : directExpression);
            }
        }
    }
    // Main visitor that rewrites await and for-await expressions, skipping entering into child functions
    var rewriteAsyncBlockVisitor = {
        Function: skipNode,
        AwaitExpression: rewriteAwaitOrYieldPath,
        YieldExpression: rewriteAwaitOrYieldPath,
        ForAwaitStatement: rewriteAwaitOrYieldPath,
        ForOfStatement: function (path) {
            if (path.node.await) { // Support babel versions with .await property on ForOfStatement type
                rewriteAwaitOrYieldPath.call(this, path);
            }
        },
        CallExpression: function (path) {
            var callee = path.get("callee");
            if (callee.isIdentifier() && callee.node.name === "eval") {
                throw path.buildCodeFrameError("Calling eval from inside an async function is not supported!", TypeError);
            }
        }
    };
    // Visitor that unpromisifies return statements, skipping functions
    var unpromisifyVisitor = {
        Function: skipNode,
        ReturnStatement: function (path) {
            var argument = path.get("argument");
            if (argument.node) {
                unpromisify(argument, this);
            }
        }
    };
    // Unpromisifies a path
    function unpromisify(path, pluginState) {
        if (path.isNumericLiteral() || path.isBooleanLiteral() || path.isStringLiteral() || path.isNullLiteral() || (path.isIdentifier() && path.node.name === "undefined") || path.isArrayExpression() || path.isObjectExpression() || path.isBinaryExpression() || path.isUnaryExpression() || path.isUpdateExpression()) {
            return;
        }
        if (path.isCallExpression() && (types.isIdentifier(path.node.callee) || types.isMemberExpression(path.node.callee)) && path.node.callee._helperName) {
            switch (path.node.callee._helperName) {
                case "_await":
                case "_call": {
                    var args = path.get("arguments");
                    if (args.length > 2) {
                        var secondArg = args[1];
                        if (types.isExpression(secondArg.node) && isContinuation(secondArg.node)) {
                            secondArg.traverse(unpromisifyVisitor, pluginState);
                        }
                        else if (secondArg.isIdentifier()) {
                            var binding = secondArg.scope.getBinding(secondArg.node.name);
                            if (binding && binding.path.isVariableDeclarator()) {
                                binding.path.get("init").traverse(unpromisifyVisitor, pluginState);
                            }
                        }
                    }
                    break;
                }
            }
            return;
        }
        if (path.isLogicalExpression()) {
            unpromisify(path.get("left"), pluginState);
            unpromisify(path.get("right"), pluginState);
            return;
        }
        if (path.isConditionalExpression()) {
            unpromisify(path.get("consequent"), pluginState);
            unpromisify(path.get("alternate"), pluginState);
            return;
        }
        if (path.isSequenceExpression()) {
            var expressions = path.get("expressions");
            if (expressions.length) {
                unpromisify(expressions[expressions.length - 1], pluginState);
            }
            return;
        }
        var minify = readConfigKey(pluginState.opts, "minify");
        path.replaceWith(logicalNot(logicalNot(path.node, minify), minify));
    }
    // Rewrites await and for-await expressions, skipping entering into child functions
    function rewriteAsyncBlock(generatorState, path, additionalConstantNames, exitIdentifier, shouldUnpromisify) {
        path.traverse(rewriteAsyncBlockVisitor, { generatorState: generatorState, path: path, additionalConstantNames: additionalConstantNames, exitIdentifier: exitIdentifier });
        if (shouldUnpromisify) {
            // Rewrite values that potentially could be promises to booleans so that they aren't awaited
            if (path.isArrowFunctionExpression()) {
                var body = path.get("body");
                if (body.isExpression()) {
                    unpromisify(body, generatorState.state);
                }
            }
            else {
                path.traverse(unpromisifyVisitor, generatorState.state);
            }
        }
    }
    // Visitor to extract dependencies from a helper function
    var getHelperDependenciesVisitor = {
        Identifier: function (path) {
            if (identifierSearchesScope(path) && path.hub.file.scope.getBinding(path.node.name) && this.dependencies.indexOf(path.node.name) === -1) {
                this.dependencies.push(path.node.name);
            }
        }
    };
    // Extract dependencies from a helper function
    function getHelperDependencies(path) {
        var state = { dependencies: [] };
        path.traverse(getHelperDependenciesVisitor, state);
        return state.dependencies;
    }
    // Visitor that checks if an identifier is used
    var usesIdentifierVisitor = {
        Identifier: function (path) {
            if (path.node.name === this.name) {
                this.found = true;
                path.stop();
            }
        }
    };
    // Check if an identifier is used by a path
    function usesIdentifier(path, name) {
        var state = { name: name, found: false };
        path.traverse(usesIdentifierVisitor, state);
        return state.found;
    }
    // Emits a reference to a helper, inlining or importing it as necessary
    function helperReference(state, path, name) {
        var file = path.scope.hub.file;
        var result = file.declarations[name];
        if (result) {
            result = cloneNode(result);
        }
        else {
            result = file.declarations[name] = usesIdentifier(file.path, name) ? file.path.scope.generateUidIdentifier(name) : types.identifier(name);
            result._helperName = name;
            if (readConfigKey(state.opts, "externalHelpers")) {
                /* istanbul ignore next */
                file.path.unshiftContainer("body", types.importDeclaration([types.importSpecifier(result, types.identifier(name))], types.stringLiteral("babel-plugin-transform-async-to-promises/helpers")));
            }
            else {
                if (!helpers) {
                    // Read helpers from ./helpers.js
                    var newHelpers_1 = {};
                    var helperCode = fs_1.readFileSync(path_1.join(__dirname, "helpers.js")).toString();
                    var helperAst = require(isNewBabel ? "@babel/core" : "babylon").parse(helperCode, { sourceType: "module" });
                    transformFromAst(helperAst, helperCode, {
                        babelrc: false, plugins: [{
                                visitor: {
                                    ExportNamedDeclaration: function (path) {
                                        var declaration = path.get("declaration");
                                        if (declaration.isFunctionDeclaration()) {
                                            newHelpers_1[declaration.node.id.name] = {
                                                value: declaration.node,
                                                dependencies: getHelperDependencies(declaration)
                                            };
                                            return;
                                        }
                                        if (declaration.isVariableDeclaration() && declaration.node.declarations.length === 1) {
                                            var declaratorId = declaration.node.declarations[0].id;
                                            if (types.isIdentifier(declaratorId)) {
                                                newHelpers_1[declaratorId.name] = {
                                                    value: declaration.node,
                                                    dependencies: getHelperDependencies(declaration)
                                                };
                                                return;
                                            }
                                        }
                                        /* istanbul ignore next */
                                        throw path.buildCodeFrameError("Expected a named export from built-in helper!", TypeError);
                                    }
                                }
                            }]
                    });
                    helpers = newHelpers_1;
                }
                var helper = helpers[name];
                for (var _i = 0, _a = helper.dependencies; _i < _a.length; _i++) {
                    var dependency = _a[_i];
                    helperReference(state, path, dependency);
                }
                var value = cloneNode(helper.value);
                var traversePath = file.path.get("body")[0];
                if (types.isVariableDeclaration(value) && traversePath.isVariableDeclaration()) {
                    // TODO: Support variable declaration that references another variable declaration (this case doesn't exist yet in our helpers, but may in the future)
                    traversePath.unshiftContainer("declarations", value.declarations[0]);
                    traversePath = file.path.get("body")[0].get("declarations")[0];
                }
                else {
                    file.path.unshiftContainer("body", value);
                    traversePath = file.path.get("body")[0];
                }
                // Rename references to other helpers due to name conflicts
                traversePath.traverse({
                    Identifier: function (path) {
                        var name = path.node.name;
                        if (Object.hasOwnProperty.call(helpers, name)) {
                            path.replaceWith(file.declarations[name]);
                        }
                    }
                });
                // Rewrite IIFE to a series of statements that assign
                if (traversePath.isVariableDeclaration()) {
                    var init = traversePath.get("declarations")[0].get("init");
                    if (init.isCallExpression() && init.get("arguments").length === 0) {
                        var callee = init.get("callee");
                        if (callee.isFunctionExpression() && callee.node.params.length === 0) {
                            var body = callee.get("body").get("body");
                            var last = body[body.length - 1];
                            if (last.isReturnStatement() && last.node.argument !== null) {
                                for (var _b = 0, _c = body.slice(0, body.length - 1); _b < _c.length; _b++) {
                                    var bodyPath = _c[_b];
                                    traversePath.insertBefore(bodyPath.node);
                                }
                                var argument = last.get("argument");
                                if (argument.isIdentifier() && argument.node._helperName === name) {
                                    traversePath.remove();
                                }
                                else {
                                    init.replaceWith(argument.node);
                                }
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
    // Emits a reference to an empty function, inlining or importing it as necessary
    function emptyFunction(state, path) {
        return readConfigKey(state.opts, "inlineHelpers") ? functionize(state, [], blockStatement([]), path) : helperReference(state, path, "_empty");
    }
    // Emits a reference to Promise.resolve and tags it as an _await reference
    function promiseResolve() {
        var result = types.memberExpression(types.identifier("Promise"), types.identifier("resolve"));
        result._helperName = "_await";
        return result;
    }
    // Emits a call to a target's then method
    function callThenMethod(value, continuation) {
        return types.callExpression(types.memberExpression(value, types.identifier("then")), [continuation]);
    }
    // Checks if an expression is an async call expression
    function isAsyncCallExpression(path) {
        if (types.isIdentifier(path.node.callee) || types.isMemberExpression(path.node.callee)) {
            switch (path.node.callee._helperName) {
                case "_await":
                case "_call":
                    return path.node.arguments.length < 3;
            }
        }
        return false;
    }
    // Extracts the invoke type of a call expression
    function invokeTypeOfExpression(path) {
        if (path.isCallExpression() && types.isIdentifier(path.node.callee)) {
            var helperName = path.node.callee._helperName;
            switch (helperName) {
                case "_invoke":
                case "_invokeIgnored":
                case "_catch":
                case "_catchInGenerator":
                case "_finally":
                case "_finallyRethrows":
                    return helperName;
            }
        }
    }
    // Checks to see if an expression is an async function
    function isAsyncFunctionExpression(path) {
        if (path.isFunction() && (path.node.async || path.node._async)) {
            return true;
        }
        if (path.isCallExpression() && types.isIdentifier(path.node.callee) && path.node.callee._helperName === "_async") {
            return true;
        }
        return false;
    }
    // Looks up if a bound function is an async function
    function isAsyncFunctionIdentifier(path) {
        if (path.isIdentifier()) {
            var binding = path.scope.getBinding(path.node.name);
            if (binding && binding.constant) {
                var bindingPath = binding.path;
                if (bindingPath.isVariableDeclarator()) {
                    var initPath = bindingPath.get("init");
                    if (initPath.node && isAsyncFunctionExpression(initPath)) {
                        return true;
                    }
                }
                else if (bindingPath.isFunctionDeclaration()) {
                    if (isAsyncFunctionExpression(bindingPath)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    // Check if an argument is arguments or eval
    function isEvalOrArguments(path) {
        return path.isIdentifier() && (path.node.name === "arguments" || path.node.name === "eval");
    }
    // Check if an indentifier at a path searches its scope
    function identifierSearchesScope(path) {
        if (path.node.name === "undefined") {
            return false;
        }
        if (path.node._helperName) {
            return false;
        }
        var parent = path.parentPath;
        if (parent.isVariableDeclarator() && parent.get("id") === path) {
            return false;
        }
        if (parent.isMemberExpression() && !parent.node.computed && parent.get("property") === path) {
            return false;
        }
        if (parent.isLabeledStatement() && parent.get("label") === path) {
            return false;
        }
        if (parent.isFunction() && parent.get("params").indexOf(path) !== -1) {
            return false;
        }
        return true;
    }
    // Visitor helper that sets the canThrow state
    function canThrow() {
        this.canThrow = true;
    }
    // Parse the promise call type of a call expression
    function promiseCallExpressionType(expression) {
        if (types.isMemberExpression(expression.callee)) {
            if (types.isIdentifier(expression.callee.object) && expression.callee.object.name === "Promise" && types.isIdentifier(expression.callee.property)) {
                switch (expression.callee.property.name) {
                    case "all":
                    case "race":
                    case "reject":
                    case "resolve":
                        return expression.callee.property.name;
                }
            }
            else if (types.isCallExpression(expression.callee.object) && types.isIdentifier(expression.callee.property)) {
                switch (expression.callee.property.name) {
                    case "then":
                    case "catch":
                    case "finally":
                        if (typeof promiseCallExpressionType(expression.callee.object) !== "undefined") {
                            return expression.callee.property.name;
                        }
                        break;
                }
            }
        }
        return undefined;
    }
    // Visitor to simplify the top level of an async function and check if it needs to be wrapped in a try/catch
    var checkForErrorsAndRewriteReturnsVisitor = {
        Function: skipNode,
        ThrowStatement: canThrow,
        ForInStatement: canThrow,
        ForOfStatement: canThrow,
        WithStatement: canThrow,
        NewExpression: canThrow,
        TryStatement: function (path) {
            if (path.get("handler")) {
                path.get("block").skip();
            }
        },
        CallExpression: function (path) {
            if (!isAsyncCallExpression(path)) {
                var args = path.get("arguments");
                switch (invokeTypeOfExpression(path)) {
                    default:
                        if (checkForErrorsAndRewriteReturns(args[0], this.plugin)) {
                            this.canThrow = true;
                        }
                    // fallthrough
                    case "_catch":
                    case "_catchInGenerator":
                    case "_finally":
                    case "_finallyRethrows":
                        if (args[1]) {
                            if (checkForErrorsAndRewriteReturns(args[1], this.plugin)) {
                                this.canThrow = true;
                            }
                        }
                        break;
                    case undefined: {
                        var callee = path.get("callee");
                        if (!isAsyncFunctionIdentifier(callee)) {
                            this.canThrow = true;
                        }
                    }
                }
            }
        },
        UpdateExpression: function (path) {
            if (isEvalOrArguments(path.get("argument"))) {
                this.canThrow = true;
            }
        },
        UnaryExpression: function (path) {
            switch (path.node.operator) {
                case "delete":
                    // Not strictly true that all delete expressions can potentially throw, but better to be cautious
                    this.canThrow = true;
                    break;
            }
        },
        BinaryExpression: function (path) {
            switch (path.node.operator) {
                case "instanceof":
                case "in":
                    this.canThrow = true;
                    break;
            }
        },
        Identifier: function (path) {
            if (identifierSearchesScope(path) && !path.scope.getBinding(path.node.name) && alwaysTruthy.indexOf(path.node.name) === -1) {
                this.canThrow = true;
            }
        },
        MemberExpression: function (path) {
            if (path.node._helperName !== "_await" && !(path.parentPath.isCallExpression() && promiseCallExpressionType(path.parentPath.node) !== undefined && path.parentPath.get("callee") === path)) {
                var propertyName = propertyNameOfMemberExpression(path.node);
                if (propertyName !== undefined) {
                    var object = path.get("object");
                    if (object.isIdentifier() && Object.hasOwnProperty.call(constantStaticMethods, object.node.name) && Object.hasOwnProperty.call(constantStaticMethods[object.node.name], propertyName)) {
                        return;
                    }
                }
                this.canThrow = true;
            }
        },
        AssignmentExpression: function (path) {
            if (isEvalOrArguments(path.get("left"))) {
                this.canThrow = true;
            }
        },
        ReturnStatement: function (path) {
            if (this.rewriteReturns) {
                var argument = path.get("argument");
                if (argument.node) {
                    if (!((argument.isCallExpression() && (isAsyncCallExpression(argument) || typeof promiseCallExpressionType(argument.node) !== "undefined")) || (argument.isCallExpression() && isAsyncFunctionIdentifier(argument.get("callee"))))) {
                        var target = readConfigKey(this.plugin.opts, "inlineHelpers") ? promiseResolve() : helperReference(this.plugin, path, "_await");
                        var arg = argument.node;
                        if (types.isConditionalExpression(arg) && types.isIdentifier(arg.test)) {
                            if (types.isCallExpression(arg.consequent) && promiseCallExpressionType(arg.consequent) === "resolve" && arg.consequent.arguments.length === 1 && nodesAreEquivalent(arg.consequent.arguments[0])(arg.alternate)) {
                                // Simplify Promise.resolve(foo ? bar() : Promise.resolve(bar())) to Promise.resolve(bar())
                                arg = arg.alternate;
                            }
                            else if (types.isCallExpression(arg.alternate) && promiseCallExpressionType(arg.alternate) === "resolve" && arg.alternate.arguments.length === 1 && nodesAreEquivalent(arg.alternate.arguments[0])(arg.consequent)) {
                                // Simplify Promise.resolve(foo ? Promise.resolve(bar()) : bar()) to Promise.resolve(bar())
                                arg = arg.consequent;
                            }
                        }
                        if (types.isConditionalExpression(arg) && types.isCallExpression(arg.consequent) && promiseCallExpressionType(arg.consequent) === "resolve") {
                            // Simplify Promise.resolve(foo ? bar : Promise.resolve(baz)) to Promise.resolve(foo ? bar : baz)
                            var consequent = arg.consequent.arguments[0];
                            if (consequent && !types.isSpreadElement(consequent)) {
                                arg = conditionalExpression(arg.test, consequent, arg.alternate);
                            }
                        }
                        if (types.isConditionalExpression(arg) && types.isCallExpression(arg.alternate) && promiseCallExpressionType(arg.alternate) === "resolve") {
                            // Simplify Promise.resolve(foo ? Promise.resolve(bar) : baz) to Promise.resolve(foo ? bar : baz)
                            var alternate = arg.alternate.arguments[0];
                            if (alternate && !types.isSpreadElement(alternate)) {
                                arg = conditionalExpression(arg.test, arg.consequent, alternate);
                            }
                        }
                        if (types.isConditionalExpression(arg) && types.isIdentifier(arg.test)) {
                            if (types.isIdentifier(arg.consequent) && arg.test.name === arg.consequent.name) {
                                if (types.isIdentifier(arg.alternate) && arg.test.name === arg.alternate.name) {
                                    // Simplify Promise.resolve(foo ? foo : foo) to Promise.resolve(foo)
                                    arg = arg.test;
                                }
                                else {
                                    // Simplify Promise.resolve(foo ? bar : foo) to Promse.resolve(foo || bar)
                                    arg = types.logicalExpression("||", arg.consequent, arg.alternate);
                                }
                            }
                            else if (types.isIdentifier(arg.alternate) && arg.test.name === arg.alternate.name) {
                                // Simplify Promise.resolve(foo ? foo : bar) to Promse.resolve(foo && bar)
                                arg = types.logicalExpression("&&", arg.alternate, arg.consequent);
                            }
                        }
                        argument.replaceWith(types.callExpression(target, [arg]));
                    }
                }
                else {
                    var target = readConfigKey(this.plugin.opts, "inlineHelpers") ? promiseResolve() : helperReference(this.plugin, path, "_await");
                    argument.replaceWith(types.callExpression(target, []));
                }
            }
        }
    };
    // Simplify the top level of an async function and check if it needs to be wrapped in a try/catch
    function checkForErrorsAndRewriteReturns(path, plugin, rewriteReturns) {
        if (rewriteReturns === void 0) { rewriteReturns = false; }
        var state = { rewriteReturns: rewriteReturns, plugin: plugin, canThrow: false };
        path.traverse(checkForErrorsAndRewriteReturnsVisitor, state);
        return state.canThrow;
    }
    // Visitor to rewrite the top level return expressions of an async function
    var rewriteTopLevelReturnsVisitor = {
        Function: skipNode,
        ReturnStatement: function (path) {
            var argument = path.get("argument");
            if (argument.isCallExpression()) {
                var callArgs = argument.node.arguments;
                switch (callArgs.length) {
                    case 3:
                    case 2: {
                        var secondArgument = callArgs[1];
                        if (!types.isUnaryExpression(secondArgument) || secondArgument.operator !== "void") {
                            break;
                        }
                        // fallthrough
                    }
                    case 1:
                        if (types.isIdentifier(argument.node.callee) || types.isMemberExpression(argument.node.callee)) {
                            var firstArgument = callArgs[0];
                            if (types.isExpression(firstArgument)) {
                                switch (argument.node.callee._helperName) {
                                    case "_await":
                                        argument.replaceWith(firstArgument);
                                        break;
                                    case "_call":
                                        argument.replaceWith(types.callExpression(firstArgument, []));
                                        break;
                                }
                            }
                        }
                        break;
                }
            }
        }
    };
    // Shuffles a path to evaluate before its non-function declaration siblings
    function reorderPathBeforeSiblingStatements(targetPath) {
        for (var _i = 0, _a = targetPath.getAllPrevSiblings().reverse(); _i < _a.length; _i++) {
            var sibling = _a[_i];
            if (!sibling.isFunctionDeclaration() && !sibling.isImportDeclaration()) {
                var newNode = targetPath.node;
                targetPath.remove();
                sibling.insertBefore(newNode);
                return;
            }
        }
    }
    // Main babel plugin implementation and top level visitor
    return {
        manipulateOptions: function (options, parserOptions) {
            parserOptions.plugins.push("asyncGenerators");
        },
        visitor: {
            FunctionDeclaration: function (path) {
                var node = path.node;
                if (node.async) {
                    var expression = types.functionExpression(undefined, node.params, node.body, node.generator, node.async);
                    if (node.id === null) {
                        path.replaceWith(expression);
                        return;
                    }
                    var declarators = [types.variableDeclarator(node.id, expression)];
                    var targetPath = void 0;
                    if (path.parentPath.isExportDeclaration()) {
                        if (path.parentPath.isExportDefaultDeclaration()) {
                            // export default function... is a function declaration in babel 7
                            var targetPath_1 = path.parentPath;
                            targetPath_1.replaceWith(types.variableDeclaration("const", declarators));
                            targetPath_1.insertAfter(types.exportDefaultDeclaration(node.id));
                            reorderPathBeforeSiblingStatements(targetPath_1);
                        }
                        else {
                            path.replaceWith(types.variableDeclaration("const", declarators));
                            reorderPathBeforeSiblingStatements(path.parentPath);
                        }
                    }
                    else {
                        path.replaceWith(types.variableDeclaration("const", declarators));
                        reorderPathBeforeSiblingStatements(path);
                    }
                }
            },
            ArrowFunctionExpression: function (path) {
                var node = path.node;
                if (node.async) {
                    rewriteThisExpressions(path, path.getFunctionParent() || path.scope.getProgramParent().path);
                    var body = types.isBlockStatement(path.node.body) ? path.node.body : blockStatement([types.returnStatement(path.node.body)]);
                    path.replaceWith(types.functionExpression(undefined, node.params, body, false, node.async));
                }
            },
            FunctionExpression: function (path) {
                if (path.node.async) {
                    var id = path.node.id;
                    if (path.parentPath.isExportDefaultDeclaration() && id !== null) {
                        // export default function... is a function expression in babel 6
                        var targetPath = path.parentPath;
                        targetPath.replaceWith(types.variableDeclaration("const", [types.variableDeclarator(path.node.id, types.functionExpression(path.node.id, path.node.params, path.node.body, path.node.generator, path.node.async))]));
                        targetPath.insertAfter(types.exportDefaultDeclaration(id));
                        reorderPathBeforeSiblingStatements(targetPath);
                        return;
                    }
                    rewriteThisArgumentsAndHoistFunctions(path, path, false);
                    var bodyPath = path.get("body");
                    if (path.node.generator) {
                        var generatorIdentifier = path.scope.generateUidIdentifier("generator");
                        path.scope.push({ kind: "const", id: generatorIdentifier, unique: true });
                        var generatorBinding = path.scope.getBinding(generatorIdentifier.name);
                        if (typeof generatorBinding === "undefined") {
                            /* istanbul ignore next */
                            throw path.buildCodeFrameError("Could not find newly created binding for " + generatorIdentifier.name + "!", Error);
                        }
                        rewriteAsyncBlock({ state: this, generatorIdentifier: generatorIdentifier }, bodyPath, []);
                        generatorBinding.path.remove();
                        path.replaceWith(functionize(this, path.node.params, types.newExpression(helperReference(this, path, "_AsyncGenerator"), [
                            functionize(this, [generatorIdentifier], bodyPath.node, path)
                        ]), path));
                    }
                    else {
                        rewriteAsyncBlock({ state: this }, path, []);
                        var inlineHelpers = readConfigKey(this.opts, "inlineHelpers");
                        var canThrow_1 = checkForErrorsAndRewriteReturns(bodyPath, this, inlineHelpers);
                        if (inlineHelpers && !pathsReturnOrThrowCurrentNodes(bodyPath).all) {
                            path.node.body.body.push(types.returnStatement());
                        }
                        if (canThrow_1) {
                            if (inlineHelpers) {
                                path.replaceWith(functionize(this, path.node.params, blockStatement(types.tryStatement(bodyPath.node, types.catchClause(types.identifier("e"), blockStatement([
                                    types.returnStatement(types.callExpression(types.memberExpression(types.identifier("Promise"), types.identifier("reject")), [types.identifier("e")]))
                                ])))), path));
                            }
                            else {
                                bodyPath.traverse(rewriteTopLevelReturnsVisitor);
                                path.replaceWith(types.callExpression(helperReference(this, path, "_async"), [
                                    functionize(this, path.node.params, bodyPath.node, path)
                                ]));
                            }
                        }
                        else {
                            if (!inlineHelpers) {
                                checkForErrorsAndRewriteReturns(bodyPath, this, true);
                            }
                            path.replaceWith(functionize(this, path.node.params, bodyPath.node, path));
                        }
                    }
                    path.node._async = true;
                }
            },
            ClassMethod: function (path) {
                if (path.node.async) {
                    var body = path.get("body");
                    var newBody = void 0;
                    if (path.node.kind === "method") {
                        body.replaceWith(types.blockStatement([
                            body.node
                        ]));
                        var target = body.get("body")[0];
                        if (!target.isBlockStatement()) {
                            /* istanbul ignore next */
                            throw path.buildCodeFrameError("Expected a BlockStatement, got a " + target.type, TypeError);
                        }
                        if (path.node.generator) {
                            var generatorIdentifier = target.scope.generateUidIdentifier("generator");
                            target.scope.push({ kind: "const", id: generatorIdentifier, init: generatorIdentifier, unique: true });
                            var generatorBinding = target.scope.getBinding(generatorIdentifier.name);
                            if (typeof generatorBinding === "undefined") {
                                /* istanbul ignore next */
                                throw path.buildCodeFrameError("Could not find newly created binding for " + generatorIdentifier.name + "!", Error);
                            }
                            rewriteAsyncBlock({ state: this, generatorIdentifier: generatorIdentifier }, target, []);
                            generatorBinding.path.remove();
                            target.replaceWith(types.returnStatement(types.newExpression(helperReference(this, path, "_AsyncGenerator"), [
                                functionize(this, [generatorIdentifier], target.node, target)
                            ])));
                        }
                        else {
                            var inlineHelpers = readConfigKey(this.opts, "inlineHelpers");
                            rewriteThisArgumentsAndHoistFunctions(target, inlineHelpers ? target : body, true);
                            rewriteAsyncBlock({ state: this }, target, []);
                            if (inlineHelpers) {
                                target.replaceWith(types.tryStatement(target.node, types.catchClause(types.identifier("e"), blockStatement([
                                    types.returnStatement(types.callExpression(types.memberExpression(types.identifier("Promise"), types.identifier("reject")), [types.identifier("e")]))
                                ]))));
                            }
                            else {
                                target.replaceWith(types.returnStatement(types.callExpression(helperReference(this, path, "_call"), [functionize(this, [], target.node, path)])));
                            }
                        }
                    }
                    path.replaceWith(types.classMethod(path.node.kind, path.node.key, path.node.params, path.node.body, path.node.computed, path.node.static));
                }
            },
            ObjectMethod: function (path) {
                if (path.node.async) {
                    if (path.node.kind === "method") {
                        path.replaceWith(types.objectProperty(path.node.key, types.functionExpression(undefined, path.node.params, path.node.body, path.node.generator, path.node.async), path.node.computed, false, path.node.decorators));
                    }
                }
            }
        }
    };
}
exports["default"] = default_1;
module.exports = exports["default"];
//# sourceMappingURL=async-to-promises.js.map